<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STEM Nature Adventures</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'story-blue': '#3b82f6',
                        'story-green': '#22c55e',
                        'story-dark': '#1e1b4b',
                        'paper': '#fefce8', // A warmer, more papery yellow
                    },
                    fontFamily: {
                        sans: ['Segoe UI', 'Tahoma', 'Geneva', 'Verdana', 'sans-serif'],
                        serif: ['Georgia', 'Cambria', 'Times New Roman', 'Times', 'serif'],
                    },
                    boxShadow: {
                        'book': '0 25px 50px -12px rgba(0, 0, 0, 0.5), 0 0 15px rgba(0,0,0,0.1)',
                    }
                }
            }
        }
    </script>
    <style>
        :root {
            --paper: #04234a;
        }
        body {
            background-color: #ffffff;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .page-container {
            display: flex;
            width: 90vw;
            max-width: 1100px;
            height: 80vh;
            background-color: var(--paper);
            border-radius: 10px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.4);
            position: relative;
            overflow: hidden;
        }

        .left-page {
            flex: 1;
            padding: 3rem;
            border-right: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
            justify-content: center;
            background: linear-gradient(to right, var(--paper) 99%, #f3f4f6 100%);
        }

        .right-page {
            flex: 1;
            position: relative;
            background-color: #111;
            overflow: hidden;
            border-left: 1px solid #d1d5db;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .nav-btn {
            transition: all 0.3s ease;
        }
        .nav-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .story-text {
            line-height: 1.8;
            font-size: 1.1rem;
            color: #ffffff;
        }
        .chapter-title {
            font-family: 'Georgia', serif;
            color: #ffffff;
            border-bottom: 3px solid #fff000;
            display: inline-block;
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }
    </style>
</head>
<body>

    <div class="page-container">
        <!-- Left Page: Story -->
        <div class="left-page">
            <div class="mb-auto">
                <h1 id="story-title" class="text-4xl font-bold mb-6 chapter-title">The Cosmic Waltz</h1>
                <div id="story-content" class="story-text">
                    <!-- Text injected by JS -->
                </div>
            </div>

            <div class="flex gap-4 mt-8 pt-6 border-t border-gray-200">
                <button id="btn-prev" onclick="Book.prev()" class="nav-btn px-6 py-2 rounded-full border-2 border-gray-300 text-white font-bold hover:border-story-blue hover:text-story-blue disabled:opacity-30 disabled:cursor-not-allowed">
                    Previous
                </button>
                <button id="btn-next" onclick="Book.next()" class="nav-btn flex-1 px-6 py-2 rounded-full bg-story-green text-white font-bold hover:bg-green-700 shadow-md">
                    Next Adventure →
                </button>
            </div>
        </div>

        <!-- Right Page: Animation -->
        <div class="right-page">
            <canvas id="sim-canvas"></canvas>
            <div class="absolute bottom-4 right-4 text-white text-s select-none">&copy; Maker Mindz</div>
        </div>
    </div>

    <script>
        const Stories = [
            // --- ASTRONOMY & EARTH ---
            { title: "The Cosmic Waltz", text: `<p class="mb-4">Long ago, a star was born. It spun and pulled dust and rocks into a grand waltz. These rocks became planets, each with its own personality.</p><p>Watch as they trace their paths through the void, a clockwork mechanism held by the invisible string of <strong>Gravity</strong>.</p>`, sim: "solarSystem" },
            { title: "The Shaking Ground", text: `<p class="mb-4">The Earth's surface is a puzzle of giant pieces called <strong>Tectonic Plates</strong>. They slowly drift, but sometimes they get stuck. When the pressure builds and they suddenly slip, the ground shakes violently.</p><p>This is an <strong>Earthquake</strong>, releasing energy as seismic waves that travel through the planet.</p>`, sim: "earthquake" },
            { title: "The Fiery Mountain", text: `<p class="mb-4">Deep beneath the Earth, rock melts into a fiery soup called <strong>Magma</strong>. Lighter than the solid rock around it, it rises, finding cracks and weaknesses in the crust.</p><p>When it bursts through the surface, a <strong>Volcano</strong> erupts, spewing ash, gas, and molten lava.</p>`, sim: "volcano" },
            { title: "The Sky's Great River", text: `<p class="mb-4">The sun's warmth turns water from oceans and lakes into an invisible gas called water vapor. This is <strong>Evaporation</strong>. As it rises, it cools and forms clouds (<strong>Condensation</strong>).</p><p>When the clouds get too heavy, the water falls back to Earth as rain, snow, or hail. This is the <strong>Water Cycle</strong>, an endless journey.</p>`, sim: "waterCycle" },
            { title: "The Flash of the Storm", text: `<p class="mb-4">Inside a storm cloud, tiny ice crystals and water droplets rub together, building up static electricity. The top of the cloud becomes positive, and the bottom becomes negative.</p><p>When the charge is strong enough, it leaps to the ground in a giant, super-hot spark we call <strong>Lightning</strong>.</p>`, sim: "lightning" },
            { title: "The Painted Sky", text: `<p class="mb-4">The Sun constantly sends out a stream of charged particles called the solar wind. Earth's magnetic field protects us, funneling these particles towards the poles.</p><p>When they hit gases in our atmosphere, they glow, creating beautiful, dancing curtains of light known as the <strong>Aurora</strong>.</p>`, sim: "aurora" },
            { title: "The Ocean's Breath", text: `<p class="mb-4">Twice a day, the ocean levels rise and fall. This is the rhythm of the <strong>Tides</strong>. It's caused by the gravitational pull of the Moon, and to a lesser extent, the Sun.</p><p>The Moon's gravity pulls the water on the near side, creating a bulge. A second bulge forms on the far side as the Earth is pulled away from the water.</p>`, sim: "tides" },
            { title: "The Star Eater", text: `<p class="mb-4">When a truly massive star dies, it can collapse under its own gravity, squeezing all its matter into an infinitely small point. This creates a <strong>Black Hole</strong>.</p><p>Its gravity is so powerful that nothing, not even light, can escape once it crosses the event horizon. It's the ultimate cosmic vacuum cleaner.</p>`, sim: "blackHole" },
            { title: "The Falling Stars", text: `<p class="mb-4">As comets travel near the Sun, they leave a trail of dust and ice. When Earth passes through this trail, the tiny debris particles burn up in our atmosphere.</p><p>We see these burning particles as bright streaks of light across the night sky, known as a <strong>Meteor Shower</strong>.</p>`, sim: "meteorShower" },
            
            // --- BIOLOGY & ECOLOGY ---
            { title: "The Leaf's Kitchen", text: `<p class="mb-4">Deep inside every green leaf, a magical kitchen is always open. The chefs are called <strong>Chloroplasts</strong>.</p><p>They use sunlight, water, and carbon dioxide to cook up sweet sugar for the plant to eat. This amazing process is called <strong>Photosynthesis</strong>.</p>`, sim: "photosynthesis" },
            { title: "The Whispering Woods", text: `<p class="mb-4">Beneath the forest floor lies a secret network. A vast, hidden web of fungal threads called a <strong>Mycelium Network</strong> connects the roots of trees.</p><p>Trees use this "Wood Wide Web" to share nutrients and send warning signals to each other about pests or drought. It's a forest's internet!</p>`, sim: "mycelium" },
            { title: "The Busy Bee's Journey", text: `<p class="mb-4">Flowers need to share pollen to make seeds. They can't walk, so they hire messengers! Bees, searching for sweet nectar, get covered in yellow pollen dust.</p><p>As a bee flies to the next flower, it carries the pollen with it, helping the plants reproduce. This is <strong>Pollination</strong>.</p>`, sim: "pollination" },
            { title: "The Winged Wonder", text: `<p class="mb-4">A caterpillar's life is a story of incredible change. It hatches from an egg, eats leaves, and grows. Then, it forms a protective shell called a chrysalis.</p><p>Inside, it completely transforms its body. When it emerges, it is a beautiful butterfly. This magical change is called <strong>Metamorphosis</strong>.</p>`, sim: "metamorphosis" },
            { title: "The Wandering Seed", text: `<p class="mb-4">A plant can't walk to find a new home for its babies (seeds). So, it gives them wings! Some seeds, like dandelions, have fluffy parachutes to ride the wind.</p><p>Others have hooks to catch a ride on animal fur. This clever trick is called <strong>Seed Dispersal</strong>.</p>`, sim: "seedDispersal" },
            { title: "The Living Jewels", text: `<p class="mb-4">A <strong>Coral Reef</strong> is like a bustling underwater city, built by tiny animals called polyps. These polyps have a special friendship with tiny algae living inside them.</p><p>The algae make food for the coral using sunlight, and in return, the coral gives them a safe home. This teamwork, called symbiosis, creates the reef's vibrant colors.</p>`, sim: "coralReef" },
            { title: "The Twilight Lanterns", text: `<p class="mb-4">On a warm summer evening, you might see tiny blinking lights in the grass. These are <strong>Fireflies</strong>! They aren't on fire; they are making their own light.</p><p>A chemical reaction inside their bodies produces light without heat. This "cold light" is called <strong>Bioluminescence</strong>, and they use it to talk to each other.</p>`, sim: "fireflies" },
            { title: "The Great Migration", text: `<p class="mb-4">Many animals travel thousands of miles every year in a journey called <strong>Migration</strong>. But how do they know where to go?</p><p>Birds, turtles, and even butterflies have an amazing internal compass. They can sense the Earth's magnetic field and use it, along with the sun and stars, to navigate.</p>`, sim: "migration" },

            // --- GEOLOGY & CHEMISTRY ---
            { title: "The Crystal's Secret", text: `<p class="mb-4">No two snowflakes are exactly alike, but they all have six sides. This is because water molecules arrange themselves in a hexagonal (six-sided) lattice as they freeze.</p><p>As a tiny ice crystal falls through the clouds, more water vapor freezes onto its arms, creating its unique and beautiful pattern.</p>`, sim: "snowflake" },
            { title: "The Stone Storybook", text: `<p class="mb-4">Long ago, when a dinosaur died near a river, its bones were quickly buried by mud and sand. Over millions of years, the mud turned to rock, and minerals seeped into the bones, turning them to stone.</p><p>This creates a <strong>Fossil</strong>, a perfect stone copy that tells us a story about ancient life.</p>`, sim: "fossil" },
            { title: "The Dripping Sculptor", text: `<p class="mb-4">Deep underground, rainwater seeps through limestone rock, dissolving a mineral called calcite. Inside a cave, this water drips from the ceiling.</p><p>Each drop leaves a tiny deposit of calcite behind. Over thousands of years, these deposits grow into amazing rock formations called <strong>Stalactites</strong> (from the ceiling) and <strong>Stalagmites</strong> (from the floor).</p>`, sim: "caves" },
            { title: "The Endless Stone", text: `<p class="mb-4">The rocks beneath your feet are on an endless journey. Molten magma cools into <strong>Igneous</strong> rock. Wind and rain break it down into sand, which hardens into <strong>Sedimentary</strong> rock.</p><p>If buried and cooked by heat and pressure, it transforms into <strong>Metamorphic</strong> rock, which can melt and start the <strong>Rock Cycle</strong> all over again.</p>`, sim: "rockCycle" },
            { title: "The Earth's Hot Breath", text: `<p class="mb-4">In some places, underground water gets trapped near hot magma. The water boils, but the pressure from the rock above keeps it from turning to steam. It gets superheated!</p><p>Eventually, the pressure becomes too great, and a column of hot water and steam erupts into the air. This is a <strong>Geyser</strong>.</p>`, sim: "geyser" },

            // --- PHYSICS IN NATURE ---
            { title: "The Light-Bender's Trick", text: `<p class="mb-4">Have you ever seen a <strong>Rainbow</strong> after a storm? It's a beautiful trick of light. When sunlight passes through a raindrop, the water acts like a tiny prism.</p><p>It bends the white light and splits it into all its different colors. This bending is called <strong>Refraction</strong>, and it paints a colorful arc across the sky.</p>`, sim: "rainbow" },
            { title: "The Sun's Fiery Breath", text: `<p class="mb-4">The Sun's surface is a tangled mess of powerful magnetic fields. Sometimes, these fields snap and reconnect, releasing a tremendous burst of energy.</p><p>This explosion, called a <strong>Solar Flare</strong>, sends a wave of radiation and charged particles hurtling through space at incredible speeds.</p>`, sim: "solarFlare" }
        ];

        const Book = {
            page: 0,
            init: function() {
                this.render();
            },
            next: function() {
                if (this.page < Stories.length - 1) {
                    this.page++;
                } else {
                    this.page = 0; // Loop back to the beginning
                }
                this.render();
            },
            prev: function() {
                if (this.page > 0) {
                    this.page--;
                    this.render();
                }
            },
            render: function() {
                const story = Stories[this.page];
                document.getElementById('story-title').textContent = story.title;
                document.getElementById('story-content').innerHTML = story.text;
                
                document.getElementById('btn-prev').disabled = this.page === 0;
                document.getElementById('btn-next').disabled = false; // Always enabled for looping
                document.getElementById('btn-next').textContent = this.page === Stories.length - 1 ? "Restart Adventure" : "Next Adventure →";

                Simulations.load(story.sim);
            }
        };

        const Simulations = {
            animId: null,
            canvas: null,
            ctx: null,
            width: 0,
            height: 0,
            state: {},

            load: function(type) {
                if (this.animId) cancelAnimationFrame(this.animId);
                this.canvas = document.getElementById('sim-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.state = {}; // Reset state for new simulation
                
                const dpr = window.devicePixelRatio || 1;
                const rect = this.canvas.parentElement.getBoundingClientRect();
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.width = rect.width;
                this.height = rect.height;

                if (this[type]) this[type].init(this);
            },

            // --- SIMULATION DEFINITIONS ---

            solarSystem: {
                init: function(sim) {
                    sim.state.planets = [];
                    sim.state.stars = [];
                    for(let i=0; i<100; i++) sim.state.stars.push({ x: Math.random() * sim.width, y: Math.random() * sim.height, size: Math.random() * 2, alpha: Math.random() });
                    const colors = ['#9ca3af', '#d97706', '#3b82f6', '#ef4444', '#eab308', '#f59e0b'];
                    for(let i=0; i<6; i++) sim.state.planets.push({ r: 60 + i * 35, size: 4 + Math.random() * 8, speed: 0.02 - (i * 0.002), angle: Math.random() * Math.PI * 2, color: colors[i], trail: [] });
                    this.loop(sim);
                },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim;
                    const cx = width / 2, cy = height / 2;
                    ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, width, height);
                    ctx.fillStyle = '#fff';
                    state.stars.forEach(s => { ctx.globalAlpha = s.alpha + Math.sin(Date.now()/500)*0.2; ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill(); });
                    ctx.globalAlpha = 1;
                    const sunPulse = 20 + Math.sin(Date.now()/300) * 2;
                    const grad = ctx.createRadialGradient(cx, cy, 5, cx, cy, sunPulse * 2);
                    grad.addColorStop(0, '#fff'); grad.addColorStop(0.2, '#fcd34d'); grad.addColorStop(1, 'transparent');
                    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(cx, cy, sunPulse * 2, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#fbbf24'; ctx.beginPath(); ctx.arc(cx, cy, 15, 0, Math.PI*2); ctx.fill();
                    state.planets.forEach(p => {
                        p.angle += p.speed;
                        const x = cx + Math.cos(p.angle) * p.r, y = cy + Math.sin(p.angle) * p.r;
                        p.trail.push({x, y}); if (p.trail.length > 40) p.trail.shift();
                        ctx.beginPath(); ctx.strokeStyle = p.color; ctx.lineWidth = 2;
                        p.trail.forEach((pos, i) => { ctx.globalAlpha = i / 40; if (i===0) ctx.moveTo(pos.x, pos.y); else ctx.lineTo(pos.x, pos.y); });
                        ctx.stroke(); ctx.globalAlpha = 1;
                        ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(x, y, p.size, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.arc(x, y, p.size, p.angle + Math.PI/2, p.angle - Math.PI/2); ctx.fill();
                    });
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },

            photosynthesis: {
                init: function(sim) {
                    sim.state.particles = [];
                    this.loop(sim);
                },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim;
                    const grad = ctx.createLinearGradient(0, 0, 0, height);
                    grad.addColorStop(0, '#86efac'); grad.addColorStop(1, '#22c55e');
                    ctx.fillStyle = grad; ctx.fillRect(0, 0, width, height);
                    ctx.strokeStyle = '#16a34a'; ctx.lineWidth = 2;
                    for(let i=0; i<width; i+=50) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i + Math.sin(i)*10, height); ctx.stroke(); }
                    if (Math.random() < 0.1) state.particles.push({x: Math.random()*width, y: -10, vx: 0, vy: 2 + Math.random(), type: 'sun', r: 3});
                    if (Math.random() < 0.05) state.particles.push({x: -10, y: Math.random()*height, vx: 2, vy: (Math.random()-0.5), type: 'co2', r: 4});
                    if (Math.random() < 0.05) state.particles.push({x: Math.random()*width, y: height+10, vx: (Math.random()-0.5), vy: -2, type: 'h2o', r: 4});
                    for (let i = state.particles.length - 1; i >= 0; i--) {
                        let p = state.particles[i]; p.x += p.vx; p.y += p.vy;
                        const dx = p.x - width/2, dy = p.y - height/2;
                        if (Math.sqrt(dx*dx + dy*dy) < 50 && (p.type === 'sun' || p.type === 'co2' || p.type === 'h2o')) {
                            state.particles.splice(i, 1);
                            const newType = Math.random() > 0.5 ? 'o2' : 'sugar';
                            state.particles.push({x: width/2, y: height/2, vx: (Math.random()-0.5)*(newType==='o2'?3:1), vy: (Math.random()-0.5)*(newType==='o2'?3:1), type: newType, r: newType==='o2'?5:6, life: 100});
                            continue;
                        }
                        if (p.type === 'sun') ctx.fillStyle = '#facc15'; else if (p.type === 'co2') ctx.fillStyle = '#6b7280'; else if (p.type === 'h2o') ctx.fillStyle = '#3b82f6'; else if (p.type === 'o2') ctx.fillStyle = '#bae6fd'; else if (p.type === 'sugar') ctx.fillStyle = '#fff';
                        ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
                        if (p.x < -20 || p.x > width+20 || p.y < -20 || p.y > height+20) state.particles.splice(i, 1);
                    }
                    ctx.fillStyle = 'rgba(21, 128, 61, 0.8)'; ctx.beginPath(); ctx.ellipse(width/2, height/2, 60, 40, 0, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#86efac'; ctx.lineWidth = 3; ctx.stroke();
                    ctx.fillStyle = '#fff'; ctx.font = "12px sans-serif"; ctx.textAlign = "center"; ctx.fillText("Chloroplast", width/2, height/2 + 5);
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },

            earthquake: {
                init: function(sim) {
                    sim.state = { offset: 0, shakeTime: 0, shockwaves: [] };
                    this.loop(sim);
                },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim;
                    ctx.fillStyle = '#854d0e'; ctx.fillRect(0, 0, width, height); // Dirt
                    
                    state.shakeTime++;
                    if (state.shakeTime > 200) {
                        state.offset = (Math.random() - 0.5) * 20;
                        if (state.shakeTime > 205) {
                            state.shakeTime = 0;
                            state.offset = 0;
                            state.shockwaves.push({x: width/2, y: 150, r: 0});
                        }
                    } else {
                        state.offset = Math.sin(state.shakeTime * 0.5) * 2;
                    }

                    // Draw plates
                    ctx.fillStyle = '#a16207'; ctx.fillRect(0, 0, width/2 - 2 + state.offset, height);
                    ctx.fillStyle = '#713f12'; ctx.fillRect(width/2 + 2 + state.offset, 0, width/2 - 2, height);

                    // Draw shockwaves
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; ctx.lineWidth = 3;
                    for(let i = state.shockwaves.length - 1; i >= 0; i--) {
                        let w = state.shockwaves[i];
                        w.r += 5;
                        ctx.globalAlpha = 1 - (w.r / 400);
                        ctx.beginPath(); ctx.arc(w.x, w.y, w.r, 0, Math.PI*2); ctx.stroke();
                        if (w.r > 400) state.shockwaves.splice(i, 1);
                    }
                    ctx.globalAlpha = 1;

                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },

            volcano: {
                init: function(sim) {
                    sim.state = { particles: [], magmaY: sim.height, lava: [] };
                    this.loop(sim);
                },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim;
                    ctx.fillStyle = '#6b7280'; ctx.fillRect(0, 0, width, height); // Sky
                    
                    // Volcano shape
                    ctx.fillStyle = '#44403c';
                    ctx.beginPath(); ctx.moveTo(0, height); ctx.lineTo(width/2 - 50, 100); ctx.lineTo(width/2 + 50, 100); ctx.lineTo(width, height); ctx.fill();

                    // Magma rising
                    if (state.magmaY > 100) state.magmaY -= 0.5;
                    ctx.fillStyle = '#f97316'; ctx.fillRect(width/2 - 10, state.magmaY, 20, height - state.magmaY);

                    // Eruption
                    if (state.magmaY <= 100) {
                        for(let i=0; i<5; i++) {
                            state.particles.push({
                                x: width/2, y: 100,
                                vx: (Math.random() - 0.5) * 4,
                                vy: -5 - Math.random() * 5,
                                life: 100,
                                color: Math.random() > 0.3 ? '#57534e' : '#f59e0b'
                            });
                        }
                        // Add Lava
                        if(Math.random() < 0.3) {
                            state.lava.push({
                                x: width/2 + (Math.random()-0.5)*40, 
                                y: 100
                            });
                        }
                    }

                    // Draw Lava
                    ctx.fillStyle = '#ef4444';
                    for(let i = state.lava.length - 1; i >= 0; i--) {
                        let l = state.lava[i];
                        l.x += l.x < width/2 ? -0.5 : 0.5; // Flow down sides
                        l.y += 2;
                        ctx.beginPath(); ctx.arc(l.x, l.y, 4, 0, Math.PI*2); ctx.fill();
                        if(l.y > height) state.lava.splice(i, 1);
                    }

                    // Particles
                    for(let i = state.particles.length - 1; i >= 0; i--) {
                        let p = state.particles[i];
                        p.x += p.vx; p.y += p.vy; p.vy += 0.1; // Gravity
                        p.life--;
                        ctx.fillStyle = p.color;
                        ctx.globalAlpha = p.life / 100;
                        ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2); ctx.fill();
                        if (p.life <= 0) state.particles.splice(i, 1);
                    }
                    ctx.globalAlpha = 1;

                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },

            waterCycle: {
                init: function(sim) {
                    sim.state = { particles: [], cloudSize: 20 };
                    this.loop(sim);
                },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim;
                    ctx.fillStyle = '#7dd3fc'; ctx.fillRect(0, 0, width, height); // Sky
                    ctx.fillStyle = '#075985'; ctx.fillRect(0, height - 50, width, 50); // Water
                    ctx.fillStyle = '#fcd34d'; ctx.beginPath(); ctx.arc(50, 50, 30, 0, Math.PI*2); ctx.fill(); // Sun

                    // Evaporation
                    if (Math.random() < 0.5) state.particles.push({ x: Math.random() * width, y: height - 50, type: 'vapor', vx: (Math.random()-0.5)*0.5, vy: -1 });
                    
                    // Condensation & Precipitation
                    if (state.cloudSize > 80 && Math.random() < 0.5) state.particles.push({ x: width/2 - 40 + Math.random()*80, y: 100, type: 'rain', vy: 5 });

                    // Cloud
                    const cloudColor = Math.floor(255 - state.cloudSize);
                    ctx.fillStyle = `rgb(${cloudColor},${cloudColor},${cloudColor})`;
                    ctx.beginPath(); ctx.arc(width/2, 100, state.cloudSize, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(width/2-40, 100, state.cloudSize*0.8, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(width/2+40, 100, state.cloudSize*0.8, 0, Math.PI*2); ctx.fill();

                    // Particles
                    for(let i = state.particles.length - 1; i >= 0; i--) {
                        let p = state.particles[i]; p.x += p.vx || 0; p.y += p.vy;
                        if (p.type === 'vapor') {
                            ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
                            if (p.y < 120) { state.particles.splice(i, 1); if(state.cloudSize < 100) state.cloudSize += 0.5; }
                        } else if (p.type === 'rain') {
                            ctx.strokeStyle = '#0ea5e9'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y-10); ctx.stroke();
                            if (p.y > height - 50) { state.particles.splice(i, 1); }
                        }
                    }
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },

            lightning: {
                init: function(sim) {
                    const { width, height } = sim;
                    const cityscapePath = new Path2D();
                    cityscapePath.moveTo(0, height);
                    cityscapePath.lineTo(0, height - 40);

                    // Generate a jagged city skyline with trees once
                    for (let x = 0; x < width; x += 20) {
                        const buildingHeight = 40 + Math.random() * 80;
                        const treeHeight = 30 + Math.random() * 40;

                        if (Math.random() > 0.4) { // Building
                            cityscapePath.lineTo(x, height - buildingHeight);
                            cityscapePath.lineTo(x + 20, height - buildingHeight);
                        } else { // Tree
                            cityscapePath.lineTo(x, height - 40); // back to ground
                            cityscapePath.lineTo(x + 10, height - 40 - treeHeight); // peak of tree
                            cityscapePath.lineTo(x + 20, height - 40); // back to ground
                        }
                    }
                    cityscapePath.lineTo(width, height - 40);
                    cityscapePath.lineTo(width, height);
                    cityscapePath.closePath();

                    sim.state = { bolt: null, time: 0, cityscapePath: cityscapePath };
                    this.loop(sim);
                },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim;
                    ctx.fillStyle = '#1e293b'; ctx.fillRect(0, 0, width, height); // Night sky

                    // Ground and Cityscape Silhouette
                    ctx.fillStyle = '#0c0a09';
                    ctx.fill(state.cityscapePath);
                    
                    // Cloud
                    ctx.fillStyle = '#475569';
                    ctx.beginPath(); ctx.ellipse(width/2, 80, 150, 50, 0, 0, Math.PI*2); ctx.fill();

                    state.time++;
                    if (state.time > 150 && !state.bolt) {
                        // Create bolt
                        state.bolt = [{x: width/2, y: 130}];
                        for(let i=0; i<10; i++) {
                            let last = state.bolt[state.bolt.length-1];
                            state.bolt.push({x: last.x + (Math.random()-0.5)*40, y: last.y + 20 + Math.random()*20});
                        }
                    }
                    if (state.time > 160) { state.bolt = null; state.time = 0; }

                    // Draw bolt
                    if (state.bolt) {
                        ctx.strokeStyle = '#fef08a'; ctx.lineWidth = 4;
                        ctx.shadowColor = '#fef08a'; ctx.shadowBlur = 20;
                        ctx.beginPath();
                        state.bolt.forEach((p, i) => { if(i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y); });
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    } else {
                        // Draw charges building up
                        ctx.fillStyle = '#f87171'; ctx.font = 'bold 16px sans-serif';
                        for(let i=0; i<10; i++) ctx.fillText('+', width/2 - 100 + Math.random()*200, 60 + Math.random()*20);
                        ctx.fillStyle = '#60a5fa';
                        for(let i=0; i<10; i++) ctx.fillText('-', width/2 - 100 + Math.random()*200, 100 + Math.random()*20);
                    }
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },

            // --- Helper for other sims ---
            createParticles: function(sim, count) {
                sim.state.particles = [];
                for(let i=0; i<count; i++) {
                    sim.state.particles.push({
                        x: Math.random() * sim.width,
                        y: Math.random() * sim.height,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        r: Math.random() * 3 + 1,
                        life: 1
                    });
                }
            },

            // --- Placeholder for other 19 stories ---
            mycelium: {
                init: function(sim) {
                    sim.state = { nodes: [], pulses: [] };
                    // Create tree roots/nodes
                    for(let i=0; i<6; i++) {
                        sim.state.nodes.push({
                            x: 40 + i * (sim.width / 6) + Math.random()*30,
                            y: 280 + Math.random() * 100,
                            connections: []
                        });
                    }
                    // Connect nodes
                    sim.state.nodes.forEach((n, i) => {
                        sim.state.nodes.forEach((n2, j) => {
                            const dist = Math.sqrt((n.x-n2.x)**2 + (n.y-n2.y)**2);
                            if (i !== j && dist < 200 && Math.random() < 0.5) {
                                n.connections.push(n2);
                            }
                        });
                    });
                    this.loop(sim);
                },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim;
                    ctx.fillStyle = '#3f2e26'; // Dark soil
                    ctx.fillRect(0, 0, width, height);

                    // Draw Roots/Nodes
                    state.nodes.forEach(n => {
                        // Draw root going up
                        ctx.strokeStyle = '#8b6b5d'; ctx.lineWidth = 6;
                        ctx.beginPath(); ctx.moveTo(n.x, n.y); 
                        ctx.quadraticCurveTo(n.x + (Math.random()-0.5)*10, n.y/2, n.x, 0); 
                        ctx.stroke();
                        
                        ctx.fillStyle = '#a88d7b';
                        ctx.beginPath(); ctx.arc(n.x, n.y, 6, 0, Math.PI*2); ctx.fill();
                    });

                    // Draw Mycelium Threads
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 1;
                    state.nodes.forEach(n => {
                        n.connections.forEach(n2 => {
                            ctx.beginPath(); ctx.moveTo(n.x, n.y); 
                            const cx = (n.x + n2.x) / 2;
                            const cy = (n.y + n2.y) / 2 + 30;
                            ctx.quadraticCurveTo(cx, cy, n2.x, n2.y);
                            ctx.stroke();
                        });
                    });

                    // Spawn Pulses (Signals)
                    if (Math.random() < 0.1) {
                        const startNode = state.nodes[Math.floor(Math.random() * state.nodes.length)];
                        if (startNode.connections.length > 0) {
                            const endNode = startNode.connections[Math.floor(Math.random() * startNode.connections.length)];
                            state.pulses.push({
                                start: startNode,
                                end: endNode,
                                progress: 0,
                                speed: 0.02 + Math.random() * 0.02
                            });
                        }
                    }

                    // Update Pulses
                    ctx.fillStyle = '#86efac'; // Glowing green signal
                    ctx.shadowColor = '#86efac'; ctx.shadowBlur = 5;
                    for (let i = state.pulses.length - 1; i >= 0; i--) {
                        let p = state.pulses[i];
                        p.progress += p.speed;
                        
                        const n = p.start;
                        const n2 = p.end;
                        const cx = (n.x + n2.x) / 2;
                        const cy = (n.y + n2.y) / 2 + 30;
                        
                        const t = p.progress;
                        const invT = 1 - t;
                        const x = invT * invT * n.x + 2 * invT * t * cx + t * t * n2.x;
                        const y = invT * invT * n.y + 2 * invT * t * cy + t * t * n2.y;

                        ctx.beginPath(); ctx.arc(x, y, 2, 0, Math.PI*2); ctx.fill();
                        
                        if (p.progress >= 1) state.pulses.splice(i, 1);
                    }
                    ctx.shadowBlur = 0;

                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            
            aurora: {
                init: function(sim) {
                    sim.state = { t: 0 };
                    this.loop(sim);
                },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim;
                    state.t += 0.02;
                    
                    // Background
                    ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, width, height);
                    
                    // Stars
                    ctx.fillStyle = '#fff';
                    for(let i=0; i<50; i++) {
                        const x = (Math.sin(i*123)*10000) % width; 
                        const y = (Math.cos(i*456)*10000) % height;
                        ctx.globalAlpha = 0.5 + 0.5 * Math.sin(state.t + i);
                        ctx.fillRect(Math.abs(x), Math.abs(y), 1.5, 1.5);
                    }
                    ctx.globalAlpha = 1;

                    // Aurora Curtains
                    const drawCurtain = (color, offset, speed) => {
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.moveTo(0, height);
                        for (let x = 0; x <= width; x += 10) {
                            const y = 50 + Math.sin(x * 0.01 + state.t * speed + offset) * 50 
                                          + Math.sin(x * 0.02 + state.t * 0.5) * 30;
                            ctx.lineTo(x, y);
                        }
                        ctx.lineTo(width, height);
                        ctx.fill();
                    };

                    ctx.globalCompositeOperation = 'screen'; 
                    const grad1 = ctx.createLinearGradient(0, 0, 0, height);
                    grad1.addColorStop(0, 'rgba(74, 222, 128, 0)');
                    grad1.addColorStop(0.3, 'rgba(74, 222, 128, 0.6)'); 
                    grad1.addColorStop(1, 'rgba(74, 222, 128, 0)');
                    drawCurtain(grad1, 0, 1);

                    const grad2 = ctx.createLinearGradient(0, 0, 0, height);
                    grad2.addColorStop(0, 'rgba(168, 85, 247, 0)');
                    grad2.addColorStop(0.4, 'rgba(168, 85, 247, 0.5)'); 
                    grad2.addColorStop(1, 'rgba(168, 85, 247, 0)');
                    drawCurtain(grad2, 2, 1.5);
                    ctx.globalCompositeOperation = 'source-over';

                    // Mountains
                    ctx.fillStyle = '#020617';
                    ctx.beginPath(); ctx.moveTo(0, height); ctx.lineTo(0, height - 60);
                    ctx.lineTo(width*0.3, height - 150); ctx.lineTo(width*0.6, height - 80);
                    ctx.lineTo(width, height - 130); ctx.lineTo(width, height); ctx.fill();

                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },

            tides: {
                init: function(sim) {
                    sim.state = { time: 0 };
                    this.loop(sim);
                },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim;
                    state.time += 0.005;

                    // --- Sky and Celestial Body ---
                    const skyColor = `hsl(210, 50%, ${50 + 40 * Math.sin(state.time)})`; // Day/night cycle
                    ctx.fillStyle = skyColor;
                    ctx.fillRect(0, 0, width, height);

                    // Moon/Sun
                    const bodyX = (state.time * 50) % (width + 100) - 50;
                    const bodyY = height / 2 - Math.sin((bodyX + 50) / (width + 100) * Math.PI) * (height / 2 - 20);
                    const isMoon = Math.sin(state.time) < 0;
                    ctx.fillStyle = isMoon ? '#e2e8f0' : '#fcd34d';
                    ctx.beginPath();
                    ctx.arc(bodyX, bodyY, 20, 0, Math.PI * 2);
                    ctx.fill();

                    // --- Water and Land ---
                    const landHeight = 80;
                    ctx.fillStyle = '#f59e0b'; // Sandy color
                    ctx.beginPath();
                    ctx.moveTo(0, height - landHeight);
                    ctx.bezierCurveTo(width * 0.3, height - landHeight - 20, width * 0.7, height - landHeight + 20, width, height - landHeight);
                    ctx.lineTo(width, height);
                    ctx.lineTo(0, height);
                    ctx.closePath();
                    ctx.fill();

                    // Tide level based on time (linked to celestial body position)
                    const tideLevel = (height - landHeight - 10) + Math.cos(state.time * 2) * 30; // High tide when body is overhead/underfoot

                    // Water
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
                    ctx.beginPath();
                    ctx.moveTo(0, tideLevel);
                    for (let x = 0; x < width; x++) {
                        ctx.lineTo(x, tideLevel + Math.sin(x * 0.05 + state.time * 5) * 3);
                    }
                    ctx.lineTo(width, height);
                    ctx.lineTo(0, height);
                    ctx.closePath();
                    ctx.fill();

                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            
            snowflake: {
                init: function(sim) {
                    sim.state = { len: 0 };
                    this.loop(sim);
                },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim;
                    ctx.fillStyle = '#1e3a8a'; ctx.fillRect(0,0,width,height);
                    if(state.len < 100) state.len += 0.5;
                    
                    const drawFlake = (x, y, scale) => {
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.scale(scale, scale);
                        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
                        for(let i=0; i<6; i++) {
                            ctx.rotate(Math.PI/3);
                            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0, state.len); ctx.stroke();
                            if(state.len > 20) { ctx.beginPath(); ctx.moveTo(0, 20); ctx.lineTo(10, 30); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, 20); ctx.lineTo(-10, 30); ctx.stroke(); }
                            if(state.len > 50) { ctx.beginPath(); ctx.moveTo(0, 50); ctx.lineTo(20, 70); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, 50); ctx.lineTo(-20, 70); ctx.stroke(); }
                        }
                        ctx.restore();
                    };

                    drawFlake(width/2 - 80, height/2 - 80, 1);
                    drawFlake(width/2 + 120, height/2 + 80, 0.7);

                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },

            rainbow: {
                init: function(sim) {
                    sim.state = { t: 0 };
                    this.loop(sim);
                },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim;
                    state.t += 0.01;
                    
                    // Dark background for spectrum visibility
                    ctx.fillStyle = '#111827'; 
                    ctx.fillRect(0, 0, width, height);

                    const cx = width / 2;
                    const cy = height / 2;

                    // Prism (Equilateral Triangle)
                    const size = 120;
                    const hTri = size * Math.sqrt(3) / 2;
                    const p1 = {x: cx, y: cy - hTri/2 - 20}; // Top
                    const p2 = {x: cx - size/2, y: cy + hTri/2 - 20}; // Bottom Left
                    const p3 = {x: cx + size/2, y: cy + hTri/2 - 20}; // Bottom Right

                    // Draw Prism
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.lineTo(p3.x, p3.y);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Incoming White Light
                    // Hit the left side (p1-p2)
                    const entryT = 0.6 + Math.sin(state.t) * 0.1; // Oscillate hit position
                    const entryX = p1.x + (p2.x - p1.x) * entryT;
                    const entryY = p1.y + (p2.y - p1.y) * entryT;

                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(0, entryY + 50); // Coming from left-ish
                    ctx.lineTo(entryX, entryY);
                    ctx.stroke();

                    // Spectrum
                    const colors = [
                        '#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3'
                    ];

                    colors.forEach((col, i) => {
                        ctx.strokeStyle = col;
                        ctx.lineWidth = 5;
                        ctx.globalAlpha = 0.8;
                        
                        // Refraction inside (hit right side p1-p3)
                        // Fake physics: spread them out based on index
                        const exitT = entryT + 0.1 + (i * 0.015); // Lower down on right side
                        
                        const exitX = p1.x + (p3.x - p1.x) * exitT;
                        const exitY = p1.y + (p3.y - p1.y) * exitT;

                        ctx.beginPath();
                        ctx.moveTo(entryX, entryY);
                        ctx.lineTo(exitX, exitY);
                        ctx.stroke();

                        // Exit refraction
                        const finalX = width;
                        const finalY = exitY + (exitY - entryY) * 2 + (i * 30);
                        
                        ctx.beginPath();
                        ctx.moveTo(exitX, exitY);
                        ctx.lineTo(finalX, finalY);
                        ctx.stroke();
                    });
                    ctx.globalAlpha = 1;

                    // Label
                    ctx.fillStyle = '#fff';
                    ctx.font = '14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText("Prism Refraction", cx, cy + 100);

                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            pollination: {
                init: function(sim) {
                    sim.state = { bee: {x: 50, y: 100, target: 0}, flowers: [] };
                    for(let i=0; i<3; i++) sim.state.flowers.push({x: 100 + i*150, y: 300});
                    this.loop(sim);
                },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim;
                    ctx.fillStyle = '#87CEEB'; ctx.fillRect(0,0,width,height);
                    state.flowers.forEach(f => {
                        ctx.fillStyle = '#228B22'; ctx.fillRect(f.x-2, f.y, 4, 50);
                        ctx.fillStyle = '#FF69B4'; ctx.beginPath(); ctx.arc(f.x, f.y, 15, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(f.x, f.y, 5, 0, Math.PI*2); ctx.fill();
                    });
                    const target = state.flowers[state.bee.target];
                    const dx = target.x - state.bee.x, dy = (target.y - 20) - state.bee.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if(dist < 5) state.bee.target = (state.bee.target + 1) % state.flowers.length;
                    else { state.bee.x += (dx/dist)*2; state.bee.y += (dy/dist)*2; }
                    ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(state.bee.x, state.bee.y, 8, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#000'; ctx.fillRect(state.bee.x-2, state.bee.y-8, 4, 16);
                    ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.beginPath(); ctx.ellipse(state.bee.x-5, state.bee.y-5, 8, 4, Math.sin(Date.now()/50), 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(state.bee.x+5, state.bee.y-5, 8, 4, -Math.sin(Date.now()/50), 0, Math.PI*2); ctx.fill();
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            metamorphosis: {
                init: function(sim) {
                    sim.state = { stage: 0, timer: 0, x: 50 };
                    this.loop(sim);
                },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim;
                    ctx.fillStyle = '#728FCE'; ctx.fillRect(0,0,width,height);

                    // Wild plants at the bottom
                    const time = Date.now() / 500;
                    for(let i=0; i<width; i+=15) {
                        ctx.fillStyle = '#22c55e';
                        const h = 40 + Math.sin(i*0.1 + time)*10;
                        ctx.beginPath();
                        ctx.moveTo(i, height);
                        ctx.quadraticCurveTo(i+5, height-h/2, i + Math.sin(time*2 + i)*5, height-h);
                        ctx.lineTo(i+10, height);
                        ctx.fill();
                    }

                    ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 10; ctx.beginPath(); ctx.moveTo(0, 200); ctx.lineTo(width, 200); ctx.stroke();
                    state.timer++;
                    if(state.timer > 200) { state.stage = (state.stage + 1) % 4; state.timer = 0; state.x = 50; }
                    if(state.stage === 0) { ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(width/2, 195, 5, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#000'; ctx.fillText("Egg", width/2-10, 180); }
                    else if(state.stage === 1) { state.x += 0.5; ctx.fillStyle = '#7CFC00'; for(let i=0; i<5; i++) { ctx.beginPath(); ctx.arc(state.x + i*10, 190 + Math.sin(state.timer*0.2 + i)*2, 6, 0, Math.PI*2); ctx.fill(); } ctx.fillStyle = '#000'; ctx.fillText("Larva", state.x, 170); }
                    else if(state.stage === 2) { ctx.fillStyle = '#8FBC8F'; ctx.beginPath(); ctx.ellipse(width/2, 210, 10, 20, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#000'; ctx.fillText("Pupa", width/2-15, 240); }
                    else { state.x += 2; const y = 150 + Math.sin(state.timer*0.1)*30; ctx.fillStyle = '#FFA500'; ctx.beginPath(); ctx.moveTo(state.x, y); ctx.lineTo(state.x-15, y-15); ctx.lineTo(state.x-15, y+15); ctx.fill(); ctx.beginPath(); ctx.moveTo(state.x, y); ctx.lineTo(state.x+15, y-15); ctx.lineTo(state.x+15, y+15); ctx.fill(); ctx.fillStyle = '#000'; ctx.fillRect(state.x-2, y-10, 4, 20); ctx.fillText("Butterfly", state.x-20, y-30); }
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            seedDispersal: {
                init: function(sim) {
                    sim.state = { seeds: [] };
                    this.loop(sim);
                },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim;
                    ctx.fillStyle = '#87CEEB'; ctx.fillRect(0,0,width,height);
                    ctx.fillStyle = '#228B22'; ctx.fillRect(0, height-20, width, 20);
                    ctx.strokeStyle = '#228B22'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(100, height-20); ctx.lineTo(100, height-150); ctx.stroke();
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(100, height-150, 10, 0, Math.PI*2); ctx.fill();
                    if(Math.random() < 0.05) state.seeds.push({x: 100, y: height-150, vx: 1+Math.random(), vy: -0.5+Math.random()});
                    state.seeds.forEach((s, i) => { s.x += s.vx; s.y += s.vy; ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(s.x-5, s.y-5); ctx.stroke(); ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(s.x-5, s.y+5); ctx.stroke(); if(s.x > width) state.seeds.splice(i, 1); });
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            coralReef: {
                init: function(sim) {
                    sim.state = { 
                        fish: [],
                        bubbles: [],
                        corals: [],
                        time: 0
                    };
                    
                    // Initialize Fish
                    for(let i=0; i<15; i++) {
                        sim.state.fish.push({
                            x: Math.random()*sim.width, 
                            y: Math.random()*(sim.height - 100), 
                            vx: (Math.random()-0.5)*3, 
                            color: `hsl(${Math.random()*360}, 80%, 60%)`,
                            size: 5 + Math.random() * 8
                        });
                    }

                    // Initialize Corals
                    const numCorals = Math.floor(sim.width / 15);
                    for(let i=0; i<numCorals; i++) {
                        sim.state.corals.push({
                            x: i * 15 + Math.random()*5,
                            h: 40 + Math.random() * 60,
                            color: `hsl(${Math.random()*60 + 300}, 70%, ${40 + Math.random()*20}%)`, // Pinks/Purples/Reds
                            type: Math.random() > 0.5 ? 'round' : 'branch'
                        });
                    }
                    
                    this.loop(sim);
                },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim;
                    state.time += 0.02;

                    // Water Gradient
                    const grad = ctx.createLinearGradient(0, 0, 0, height);
                    grad.addColorStop(0, '#00b4db');
                    grad.addColorStop(1, '#0083b0');
                    ctx.fillStyle = grad; 
                    ctx.fillRect(0,0,width,height);

                    // Draw Corals
                    state.corals.forEach((c, i) => {
                        ctx.fillStyle = c.color;
                        const sway = Math.sin(state.time + i * 0.5) * 5;
                        
                        if (c.type === 'round') {
                            ctx.beginPath();
                            ctx.ellipse(c.x, height, 10, c.h/2, 0, Math.PI, 0);
                            ctx.fill();
                        } else {
                            // Branch/Seaweed like
                            ctx.beginPath();
                            ctx.moveTo(c.x, height);
                            ctx.quadraticCurveTo(c.x + sway, height - c.h/2, c.x + sway*1.5, height - c.h);
                            ctx.lineWidth = 4;
                            ctx.strokeStyle = c.color;
                            ctx.stroke();
                        }
                    });

                    // Bubbles
                    if (Math.random() < 0.05) {
                        state.bubbles.push({x: Math.random()*width, y: height, r: Math.random()*3 + 1, v: Math.random()*1 + 0.5});
                    }
                    for (let i = state.bubbles.length - 1; i >= 0; i--) {
                        let b = state.bubbles[i];
                        b.y -= b.v;
                        b.x += Math.sin(b.y * 0.05) * 0.5;
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
                        if (b.y < 0) state.bubbles.splice(i, 1);
                    }

                    // Fish
                    state.fish.forEach(f => { 
                        f.x += f.vx; 
                        if(f.x < -20) f.x = width + 20;
                        if(f.x > width + 20) f.x = -20;
                        
                        ctx.save();
                        ctx.translate(f.x, f.y);
                        if (f.vx < 0) ctx.scale(-1, 1);

                        ctx.fillStyle = f.color; 
                        // Body
                        ctx.beginPath(); 
                        ctx.ellipse(0, 0, f.size, f.size/1.5, 0, 0, Math.PI*2); 
                        ctx.fill(); 
                        // Tail
                        ctx.beginPath(); 
                        ctx.moveTo(-f.size/2, 0); 
                        ctx.lineTo(-f.size-5, -5); 
                        ctx.lineTo(-f.size-5, 5); 
                        ctx.fill();
                        // Eye
                        ctx.fillStyle = 'white';
                        ctx.beginPath(); ctx.arc(f.size/2, -2, 2, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = 'black';
                        ctx.beginPath(); ctx.arc(f.size/2 + 1, -2, 1, 0, Math.PI*2); ctx.fill();

                        ctx.restore();
                    });
                    
                    // Sun rays
                    ctx.save();
                    ctx.globalCompositeOperation = 'overlay';
                    const rayGrad = ctx.createLinearGradient(0, 0, 0, height);
                    rayGrad.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
                    rayGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = rayGrad;
                    ctx.beginPath();
                    ctx.moveTo(0, 0); ctx.lineTo(width, 0); ctx.lineTo(width * 0.8, height); ctx.lineTo(width * 0.2, height);
                    ctx.fill();
                    ctx.restore();

                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            fireflies: {
                init: function(sim) {
                    sim.state = { flies: [] };
                    for(let i=0; i<30; i++) sim.state.flies.push({x: Math.random()*sim.width, y: Math.random()*sim.height, t: Math.random()*100});
                    this.loop(sim);
                },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim;
                    ctx.fillStyle = '#020617'; ctx.fillRect(0,0,width,height);
                    state.flies.forEach(f => { f.x += (Math.random()-0.5); f.y += (Math.random()-0.5); f.t += 0.1; const alpha = (Math.sin(f.t)+1)/2; ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`; ctx.beginPath(); ctx.arc(f.x, f.y, 3, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 10; ctx.shadowColor = 'yellow'; ctx.fill(); ctx.shadowBlur = 0; });
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            fossil: {
                init: function(sim) {
                    sim.state = { sedimentH: 0 };
                    this.loop(sim);
                },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim;
                    
                    // 1. Sky & Base Ground
                    ctx.fillStyle = '#87CEEB'; ctx.fillRect(0, 0, width, height);
                    ctx.fillStyle = '#5D4037'; ctx.fillRect(0, height-40, width, 40);

                    // 2. Calculate Fossilization State (0 = fresh, 1 = fossilized)
                    const fossilFactor = Math.min(1, Math.max(0, (state.sedimentH - 30) / 100));
                    
                    // Interpolate color: White (#FFF) to Stone (#4E342E)
                    const r = 255 - (255-78)*fossilFactor;
                    const g = 255 - (255-52)*fossilFactor;
                    const b = 255 - (255-46)*fossilFactor;
                    const boneColor = `rgb(${r},${g},${b})`;

                    // 3. Draw Skeleton
                    ctx.save();
                    ctx.translate(width/2, height-45);
                    ctx.strokeStyle = boneColor; ctx.lineWidth = 4; ctx.lineCap = 'round'; ctx.fillStyle = boneColor;
                    
                    // Draw Dino Skeleton
                    ctx.beginPath(); ctx.moveTo(-40, 0); ctx.quadraticCurveTo(0, -10, 50, 5); ctx.stroke(); // Spine
                    for(let i=-20; i<20; i+=8) { ctx.beginPath(); ctx.moveTo(i, -5); ctx.lineTo(i, 5); ctx.stroke(); } // Ribs
                    ctx.beginPath(); ctx.moveTo(-40, 0); ctx.lineTo(-55, -5); ctx.lineTo(-60, 5); ctx.lineTo(-45, 5); ctx.closePath(); ctx.fill(); // Head
                    ctx.beginPath(); ctx.moveTo(-20, 0); ctx.lineTo(-25, 20); ctx.stroke(); // Leg
                    ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(25, 20); ctx.stroke(); // Leg
                    ctx.restore();

                    // 4. Sediment Accumulation
                    if (state.sedimentH < height - 40) state.sedimentH += 0.5;
                    
                    // Draw Layers
                    let currentY = height - 40;
                    let remaining = state.sedimentH;
                    const layers = [
                        {h: 40, c: 'rgba(121, 85, 72, 0.7)'}, // Mud
                        {h: 40, c: 'rgba(141, 110, 99, 0.7)'}, // Silt
                        {h: 60, c: 'rgba(161, 136, 127, 0.8)'}, // Sand
                        {h: 200, c: 'rgba(62, 39, 35, 0.9)'}   // Rock
                    ];

                    layers.forEach(l => {
                        if (remaining > 0) {
                            const h = Math.min(remaining, l.h);
                            ctx.fillStyle = l.c;
                            ctx.fillRect(0, currentY - h, width, h);
                            currentY -= h;
                            remaining -= h;
                        }
                    });

                    // 5. Text
                    ctx.fillStyle = '#000';
                    ctx.font = '14px sans-serif';
                    if (fossilFactor < 0.2) ctx.fillText("Burial...", 10, 30);
                    else if (fossilFactor < 0.8) ctx.fillText("Pressure & Time...", 10, 30);
                    else ctx.fillText("Fossilized!", 10, 30);

                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            caves: {
                init: function(sim) {
                    sim.state = { h: 0, dropY: 0 };
                    this.loop(sim);
                },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim;
                    ctx.fillStyle = '#2c2c2c'; ctx.fillRect(0,0,width,height);
                    if(state.h < 100) state.h += 0.1;
                    ctx.fillStyle = '#d3d3d3'; ctx.beginPath(); ctx.moveTo(width/2-20, 0); ctx.lineTo(width/2+20, 0); ctx.lineTo(width/2, state.h); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(width/2-20, height); ctx.lineTo(width/2+20, height); ctx.lineTo(width/2, height-state.h); ctx.fill();
                    state.dropY += 5; if(state.dropY > height) state.dropY = state.h;
                    ctx.fillStyle = '#00f'; ctx.beginPath(); ctx.arc(width/2, state.dropY, 3, 0, Math.PI*2); ctx.fill();
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            rockCycle: {
                init: function(sim) {
                    sim.state = { angle: 0 };
                    this.loop(sim);
                },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim;
                    ctx.fillStyle = '#FAB972'; ctx.fillRect(0,0,width,height);
                    state.angle += 0.01;
                    const cx = width/2, cy = height/2, r = 100;
                    const types = ['Magma', 'Igneous', 'Sediment', 'Sedimentary', 'Metamorphic'];
                    const colors = ['#f00', '#555', '#eec', '#d2b48c', '#708090'];
                    types.forEach((t, i) => {
                        const a = state.angle + (i * Math.PI*2 / types.length);
                        const x = cx + Math.cos(a) * r, y = cy + Math.sin(a) * r;
                        ctx.fillStyle = colors[i]; ctx.beginPath(); ctx.arc(x, y, 30, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = '#000'; ctx.textAlign = 'center'; ctx.fillText(t, x, y+40);
                    });
                    ctx.strokeStyle = '#000'; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            geyser: {
                init: function(sim) {
                    sim.state = { pressure: 0, erupting: false, particles: [] };
                    this.loop(sim);
                },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim;
                    ctx.fillStyle = '#87CEEB'; ctx.fillRect(0,0,width,height);
                    ctx.fillStyle = '#8B4513'; ctx.fillRect(0, height-50, width, 50);
                    if(!state.erupting) { state.pressure += 1; if(state.pressure > 200) state.erupting = true; }
                    else { state.pressure -= 2; if(state.pressure < 0) state.erupting = false; for(let i=0; i<5; i++) state.particles.push({x: width/2, y: height-50, vy: -5 - Math.random()*5, vx: (Math.random()-0.5)*2}); }
                    for(let i=state.particles.length-1; i>=0; i--) { let p = state.particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.1; ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill(); if(p.y > height) state.particles.splice(i, 1); }
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            blackHole: {
                init: function(sim) {
                    sim.state = { particles: [], stars: [] };
                    // Background stars
                    for(let i=0; i<100; i++) {
                        sim.state.stars.push({
                            x: Math.random() * sim.width,
                            y: Math.random() * sim.height,
                            size: Math.random() * 1.5,
                            alpha: Math.random()
                        });
                    }
                    this.loop(sim);
                },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim;
                    const cx = width / 2, cy = height / 2;
                    
                    // Clear with trails
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
                    ctx.fillRect(0, 0, width, height);

                    // Draw background stars (static)
                    ctx.fillStyle = '#fff';
                    state.stars.forEach(s => {
                        ctx.globalAlpha = s.alpha;
                        ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill();
                    });
                    ctx.globalAlpha = 1;

                    // Spawn matter particles
                    if (state.particles.length < 200) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.max(width, height) * 0.6;
                        state.particles.push({
                            x: cx + Math.cos(angle) * dist,
                            y: cy + Math.sin(angle) * dist,
                            vx: (Math.random() - 0.5) * 2,
                            vy: (Math.random() - 0.5) * 2,
                            angle: angle,
                            dist: dist,
                            speed: 1 + Math.random()
                        });
                    }

                    // Update and draw particles
                    for (let i = state.particles.length - 1; i >= 0; i--) {
                        let p = state.particles[i];
                        
                        // Spiral movement
                        p.dist -= p.speed;
                        p.angle += 0.02 + (100 / (p.dist + 1)) * 0.001; // Faster when closer
                        p.speed += 0.05; // Accelerate in

                        p.x = cx + Math.cos(p.angle) * p.dist;
                        p.y = cy + Math.sin(p.angle) * p.dist;

                        const colorVal = Math.min(255, Math.floor(255 * (200/p.dist)));
                        ctx.fillStyle = `rgb(255, ${255-colorVal}, ${255-colorVal})`; // White to Red/Hot
                        
                        const size = Math.max(1, 3 - (p.dist / 200));
                        ctx.beginPath(); ctx.arc(p.x, p.y, size, 0, Math.PI*2); ctx.fill();

                        if (p.dist < 20) state.particles.splice(i, 1); // Event horizon
                    }

                    // Accretion Disk Glow
                    const grad = ctx.createRadialGradient(cx, cy, 20, cx, cy, 60);
                    grad.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
                    grad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath(); ctx.arc(cx, cy, 60, 0, Math.PI*2); ctx.fill();

                    // Event Horizon (Black Hole)
                    ctx.fillStyle = '#000';
                    ctx.beginPath(); ctx.arc(cx, cy, 20, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 1; ctx.stroke();

                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            meteorShower: {
                init: function(sim) {
                    sim.state = { meteors: [], stars: [] };
                    for(let i=0; i<100; i++) {
                        sim.state.stars.push({
                            x: Math.random() * sim.width,
                            y: Math.random() * sim.height,
                            size: Math.random() * 2,
                            alpha: Math.random()
                        });
                    }
                    this.loop(sim);
                },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim;
                    
                    // Fade background for trails
                    ctx.fillStyle = 'rgba(15, 23, 42, 0.3)'; 
                    ctx.fillRect(0, 0, width, height);

                    // Stars
                    ctx.fillStyle = '#fff';
                    state.stars.forEach(s => {
                        ctx.globalAlpha = s.alpha;
                        ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill();
                    });
                    ctx.globalAlpha = 1;

                    // Spawn Meteors
                    if (Math.random() < 0.1) {
                        state.meteors.push({
                            x: Math.random() * width * 1.5, // Start off-screen right/top
                            y: -50,
                            vx: -5 - Math.random() * 5,
                            vy: 3 + Math.random() * 5,
                            len: 10 + Math.random() * 20,
                            life: 1.0
                        });
                    }

                    // Update Meteors
                    ctx.strokeStyle = '#fff';
                    ctx.lineCap = 'round';
                    for (let i = state.meteors.length - 1; i >= 0; i--) {
                        let m = state.meteors[i];
                        m.x += m.vx;
                        m.y += m.vy;
                        m.life -= 0.02;

                        ctx.lineWidth = 2 * m.life;
                        ctx.globalAlpha = m.life;
                        ctx.beginPath();
                        ctx.moveTo(m.x, m.y);
                        ctx.lineTo(m.x - m.vx * 3, m.y - m.vy * 3); // Trail
                        ctx.stroke();

                        if (m.life <= 0 || m.y > height || m.x < 0) state.meteors.splice(i, 1);
                    }
                    ctx.globalAlpha = 1;

                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            solarFlare: {
                init: function(sim) {
                    sim.state = {
                        t: 0,
                        flares: [],
                        particles: [],
                        surfaceNoise: []
                    };
                    // Initialize surface noise for granulation effect
                    for(let i=0; i<100; i++) {
                        sim.state.surfaceNoise.push({
                            x: Math.random() * Math.PI * 2,
                            y: Math.random() * Math.PI,
                            size: Math.random() * 5 + 2,
                            alpha: Math.random() * 0.5 + 0.2
                        });
                    }
                    this.loop(sim);
                },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim;
                    const cx = width / 2;
                    const cy = height / 2;
                    const sunRadius = 100;
                    state.t += 0.05;

                    // Background (Space)
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, width, height);

                    // Draw Sun Halo/Corona
                    const gradient = ctx.createRadialGradient(cx, cy, sunRadius, cx, cy, sunRadius * 3);
                    gradient.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
                    gradient.addColorStop(0.2, 'rgba(255, 50, 0, 0.4)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(cx, cy, sunRadius * 3, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw Sun Body
                    const sunGrad = ctx.createRadialGradient(cx, cy, sunRadius * 0.2, cx, cy, sunRadius);
                    sunGrad.addColorStop(0, '#FDB813'); // Yellow center
                    sunGrad.addColorStop(0.8, '#FF8C00'); // Orange edge
                    sunGrad.addColorStop(1, '#FF4500'); // Red-Orange rim
                    ctx.fillStyle = sunGrad;
                    ctx.beginPath();
                    ctx.arc(cx, cy, sunRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Surface Granulation (Simple)
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(cx, cy, sunRadius, 0, Math.PI * 2);
                    ctx.clip();
                    state.surfaceNoise.forEach(n => {
                        // Rotate noise slightly
                        const angle = n.x + state.t * 0.02;
                        const r = (n.y / Math.PI) * sunRadius; // Simple mapping
                        // Project to 2D disk
                        const px = cx + Math.cos(angle) * r;
                        const py = cy + Math.sin(angle) * r * 0.8; // Flatten slightly for 3D effect
                        
                        ctx.fillStyle = `rgba(255, 200, 0, ${n.alpha})`;
                        ctx.beginPath();
                        ctx.arc(px, py, n.size, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    ctx.restore();

                    // Randomly spawn flares
                    if (Math.random() < 0.02) {
                        const angle = Math.random() * Math.PI * 2;
                        state.flares.push({
                            angle: angle,
                            life: 0,
                            maxLife: 100 + Math.random() * 100,
                            scale: 0.5 + Math.random() * 1.5
                        });
                    }

                    // Update and Draw Flares (Magnetic Loops)
                    for (let i = state.flares.length - 1; i >= 0; i--) {
                        let f = state.flares[i];
                        f.life++;
                        
                        const progress = f.life / f.maxLife;
                        const growth = Math.sin(progress * Math.PI); // 0 -> 1 -> 0
                        const loopHeight = 60 * f.scale * growth;

                        // Calculate base points on sun surface
                        const x1 = cx + Math.cos(f.angle - 0.1) * sunRadius;
                        const y1 = cy + Math.sin(f.angle - 0.1) * sunRadius;
                        const x2 = cx + Math.cos(f.angle + 0.1) * sunRadius;
                        const y2 = cy + Math.sin(f.angle + 0.1) * sunRadius;

                        // Control points for quadratic curve
                        const cX = cx + Math.cos(f.angle) * (sunRadius + loopHeight * 2);
                        const cY = cy + Math.sin(f.angle) * (sunRadius + loopHeight * 2);

                        ctx.strokeStyle = `rgba(255, 200, 100, ${growth})`;
                        ctx.lineWidth = 3 * growth;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.quadraticCurveTo(cX, cY, x2, y2);
                        ctx.stroke();

                        // Eject particles at peak
                        if (progress > 0.4 && progress < 0.6 && Math.random() < 0.3) {
                            state.particles.push({
                                x: cx + Math.cos(f.angle) * (sunRadius + loopHeight),
                                y: cy + Math.sin(f.angle) * (sunRadius + loopHeight),
                                vx: Math.cos(f.angle) * (2 + Math.random()),
                                vy: Math.sin(f.angle) * (2 + Math.random()),
                                life: 60
                            });
                        }

                        if (f.life >= f.maxLife) state.flares.splice(i, 1);
                    }

                    // Update and Draw Particles (Solar Wind/CME)
                    for (let i = state.particles.length - 1; i >= 0; i--) {
                        let p = state.particles[i];
                        p.x += p.vx;
                        p.y += p.vy;
                        p.life--;
                        
                        ctx.fillStyle = `rgba(255, 255, 200, ${p.life / 60})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                        ctx.fill();

                        if (p.life <= 0) state.particles.splice(i, 1);
                    }

                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            migration: {
                init: function(sim) {
                    sim.state = { birds: [] };
                    for(let i=0; i<20; i++) sim.state.birds.push({x: -Math.random()*100, y: 50 + Math.random()*200, speed: 2+Math.random(), offset: Math.random() * 10});
                    this.loop(sim);
                },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim;
                    ctx.fillStyle = '#87CEEB'; ctx.fillRect(0,0,width,height);
                    ctx.fillStyle = '#228B22'; ctx.beginPath(); ctx.arc(width/2, height+200, 300, 0, Math.PI*2); ctx.fill();
                    const t = Date.now() / 100;
                    state.birds.forEach(b => { 
                        b.x += b.speed; 
                        if(b.x > width + 20) b.x = -20; 
                        const wingY = Math.sin(t * 2 + b.offset) * 5;
                        ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.moveTo(b.x - 6, b.y + wingY); ctx.lineTo(b.x, b.y); ctx.lineTo(b.x + 6, b.y + wingY); ctx.stroke(); 
                    });
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },

            drawPlaceholder: function(sim, text) {
                const { ctx, width, height } = sim;
                ctx.fillStyle = '#374151';
                ctx.fillRect(0, 0, width, height);
                ctx.fillStyle = '#d1d5db';
                ctx.textAlign = 'center';
                ctx.font = '24px serif';
                ctx.fillText(text, width/2, height/2);
                ctx.font = '14px sans-serif';
                ctx.fillText("(Animation Coming Soon!)", width/2, height/2 + 30);
            }
        };

        // Start
        window.onload = function() {
            Book.init();
        };
    </script>
</body>
</html>
</html>