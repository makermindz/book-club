<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STEM Nature Adventures</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'story-blue': '#3b82f6',
                        'story-green': '#22c55e',
                        'story-dark': '#1e1b4b',
                        'paper': '#04234a',
                    },
                }
            }
        }
    </script>
    <style>
        body {
            background-color: #ffffff;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .page-container {
            display: flex;
            width: 100%;
            max-width: 1024px;
            height: 90vh;
            background-color: #04234a;
            border-radius: 0 10px 10px 0; /* Rounded on the right side only */
            /* This shadow mimics the depth of a thick book */
            box-shadow: 0 20px 30px -10px rgba(0, 0, 0, 0.5), 10px 0 20px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
            /* Added the spine border here */
            border-left: 10px solid #02152d;
        }

        .left-page {
            flex: 0 0 33.333%;
            padding: 2.5rem;
            /* This creates the "fold" line in the middle of the book */
            border-right: 2px solid rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            justify-content: center;
            background: linear-gradient(to right, #04234a 95%, #031b3a 100%);
            /* Adds a slight inner shadow to simulate the page curving into the spine */
            box-shadow: inset 15px 0 20px -10px rgba(0,0,0,0.5);
        }

        .right-page {
            flex: 0 0 66.666%; /* Matches original stem-book layout ratio */
            position: relative;
            background-color: #111;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .story-text {
            line-height: 1.6;
            font-size: 1rem;
            color: #ffffff;
            overflow-y: auto; /* Internal scroll fix */
            padding-right: 0.5rem;
        }

        /* Custom Scrollbar for Story Text */
        .story-text::-webkit-scrollbar { width: 4px; }
        .story-text::-webkit-scrollbar-thumb { background: #22c55e; border-radius: 10px; }

        .chapter-title {
            font-family: 'Georgia', serif;
            color: #ffffff;
            border-bottom: 3px solid #fff000;
            display: inline-block;
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }
    </style>
</head>
<body>

    <div class="relative flex items-center justify-center w-full max-w-5xl h-[90vh]">
        
        <div class="absolute w-full h-full bg-slate-900 rounded-r-2xl transform translate-x-3 translate-y-3 shadow-2xl z-0"></div>

        <div class="page-container z-10">
            <div class="left-page">
                <div class="mb-auto overflow-hidden flex flex-col">
                    <h1 id="story-title" class="text-3xl font-bold mb-4 chapter-title"></h1>
                    <div id="story-content" class="story-text flex-1"></div>
                </div>

                <div class="flex flex-col gap-3 mt-6 pt-6 border-t border-gray-700">
                    <button id="btn-next" onclick="Book.next()" class="w-full px-6 py-3 rounded-lg bg-story-green text-white font-bold hover:bg-green-700 shadow-md transition-all active:scale-95">
                        Next Adventure →
                    </button>
                    <button id="btn-prev" onclick="Book.prev()" class="w-full px-6 py-2 rounded-lg border border-gray-500 text-gray-300 text-sm font-bold hover:text-white hover:border-white disabled:opacity-30 transition-all">
                        Previous
                    </button>
                </div>
            </div>

            <div class="right-page">
                <canvas id="sim-canvas"></canvas>
                <div class="absolute bottom-4 right-4 text-white text-s opacity-50 select-none">&copy; Maker Mindz</div>
            </div>
        </div>
    </div>

    <script>
        const Stories = [
            { title: "The Cosmic Waltz", text: `<p class="mb-4">Long ago, a star was born. It spun and pulled dust and rocks into a grand waltz. These rocks became planets, each with its own personality.</p><p>Watch as they trace their paths through the void, a clockwork mechanism held by the invisible string of <strong>Gravity</strong>.</p>`, sim: "solarSystem" },
            { title: "The Shaking Ground", text: `<p class="mb-4">The Earth's surface is a puzzle of giant pieces called <strong>Tectonic Plates</strong>. They slowly drift, but sometimes they get stuck. When the pressure builds and they suddenly slip, the ground shakes violently.</p><p>This is an <strong>Earthquake</strong>, releasing energy as seismic waves that travel through the planet.</p>`, sim: "earthquake" },
            { title: "The Fiery Mountain", text: `<p class="mb-4">Deep beneath the Earth, rock melts into a fiery soup called <strong>Magma</strong>. Lighter than the solid rock around it, it rises, finding cracks and weaknesses in the crust.</p><p>When it bursts through the surface, a <strong>Volcano</strong> erupts, spewing ash, gas, and molten lava.</p>`, sim: "volcano" },
            { title: "The Sky's Great River", text: `<p class="mb-4">The sun's warmth turns water from oceans and lakes into an invisible gas called water vapor. This is <strong>Evaporation</strong>. As it rises, it cools and forms clouds (<strong>Condensation</strong>).</p><p>When the clouds get too heavy, the water falls back to Earth as rain, snow, or hail. This is the <strong>Water Cycle</strong>, an endless journey.</p>`, sim: "waterCycle" },
            { title: "The Flash of the Storm", text: `<p class="mb-4">Inside a storm cloud, tiny ice crystals and water droplets rub together, building up static electricity. The top of the cloud becomes positive, and the bottom becomes negative.</p><p>When the charge is strong enough, it leaps to the ground in a giant, super-hot spark we call <strong>Lightning</strong>.</p>`, sim: "lightning" },
            { title: "The Painted Sky", text: `<p class="mb-4">The Sun constantly sends out a stream of charged particles called the solar wind. Earth's magnetic field protects us, funneling these particles towards the poles.</p><p>When they hit gases in our atmosphere, they glow, creating beautiful, dancing curtains of light known as the <strong>Aurora</strong>.</p>`, sim: "aurora" },
            { title: "The Ocean's Breath", text: `<p class="mb-4">Twice a day, the ocean levels rise and fall. This is the rhythm of the <strong>Tides</strong>. It's caused by the gravitational pull of the Moon, and to a lesser extent, the Sun.</p><p>The Moon's gravity pulls the water on the near side, creating a bulge. A second bulge forms on the far side as the Earth is pulled away from the water.</p>`, sim: "tides" },
            { title: "The Star Eater", text: `<p class="mb-4">When a truly massive star dies, it can collapse under its own gravity, squeezing all its matter into an infinitely small point. This creates a <strong>Black Hole</strong>.</p><p>Its gravity is so powerful that nothing, not even light, can escape once it crosses the event horizon. It's the ultimate cosmic vacuum cleaner.</p>`, sim: "blackHole" },
            { title: "The Falling Stars", text: `<p class="mb-4">As comets travel near the Sun, they leave a trail of dust and ice. When Earth passes through this trail, the tiny debris particles burn up in our atmosphere.</p><p>We see these burning particles as bright streaks of light across the night sky, known as a <strong>Meteor Shower</strong>.</p>`, sim: "meteorShower" },
            { title: "The Leaf's Kitchen", text: `<p class="mb-4">Deep inside every green leaf, a magical kitchen is always open. The chefs are called <strong>Chloroplasts</strong>.</p><p>They use sunlight, water, and carbon dioxide to cook up sweet sugar for the plant to eat. This amazing process is called <strong>Photosynthesis</strong>.</p>`, sim: "photosynthesis" },
            { title: "The Whispering Woods", text: `<p class="mb-4">Beneath the forest floor lies a secret network. A vast, hidden web of fungal threads called a <strong>Mycelium Network</strong> connects the roots of trees.</p><p>Trees use this "Wood Wide Web" to share nutrients and send warning signals to each other about pests or drought. It's a forest's internet!</p>`, sim: "mycelium" },
            { title: "The Busy Bee's Journey", text: `<p class="mb-4">Flowers need to share pollen to make seeds. They can't walk, so they hire messengers! Bees, searching for sweet nectar, get covered in yellow pollen dust.</p><p>As a bee flies to the next flower, it carries the pollen with it, helping the plants reproduce. This is <strong>Pollination</strong>.</p>`, sim: "pollination" },
            { title: "The Winged Wonder", text: `<p class="mb-4">A caterpillar's life is a story of incredible change. It hatches from an egg, eats leaves, and grows. Then, it forms a protective shell called a chrysalis.</p><p>Inside, it completely transforms its body. When it emerges, it is a beautiful butterfly. This magical change is called <strong>Metamorphosis</strong>.</p>`, sim: "metamorphosis" },
            { title: "The Wandering Seed", text: `<p class="mb-4">A plant can't walk to find a new home for its babies (seeds). So, it gives them wings! Some seeds, like dandelions, have fluffy parachutes to ride the wind.</p><p>Others have hooks to catch a ride on animal fur. This clever trick is called <strong>Seed Dispersal</strong>.</p>`, sim: "seedDispersal" },
            { title: "The Living Jewels", text: `<p class="mb-4">A <strong>Coral Reef</strong> is like a bustling underwater city, built by tiny animals called polyps. These polyps have a special friendship with tiny algae living inside them.</p><p>The algae make food for the coral using sunlight, and in return, the coral gives them a safe home. This teamwork, called symbiosis, creates the reef's vibrant colors.</p>`, sim: "coralReef" },
            { title: "The Twilight Lanterns", text: `<p class="mb-4">On a warm summer evening, you might see tiny blinking lights in the grass. These are <strong>Fireflies</strong>! They aren't on fire; they are making their own light.</p><p>A chemical reaction inside their bodies produces light without heat. This "cold light" is called <strong>Bioluminescence</strong>, and they use it to talk to each other.</p>`, sim: "fireflies" },
            { title: "The Great Migration", text: `<p class="mb-4">Many animals travel thousands of miles every year in a journey called <strong>Migration</strong>. But how do they know where to go?</p><p>Birds, turtles, and even butterflies have an amazing internal compass. They can sense the Earth's magnetic field and use it, along with the sun and stars, to navigate.</p>`, sim: "migration" },
            { title: "The Crystal's Secret", text: `<p class="mb-4">No two snowflakes are exactly alike, but they all have six sides. This is because water molecules arrange themselves in a hexagonal (six-sided) lattice as they freeze.</p><p>As a tiny ice crystal falls through the clouds, more water vapor freezes onto its arms, creating its unique and beautiful pattern.</p>`, sim: "snowflake" },
            { title: "The Stone Storybook", text: `<p class="mb-4">Long ago, when a dinosaur died near a river, its bones were quickly buried by mud and sand. Over millions of years, the mud turned to rock, and minerals seeped into the bones, turning them to stone.</p><p>This creates a <strong>Fossil</strong>, a perfect stone copy that tells us a story about ancient life.</p>`, sim: "fossil" },
            { title: "The Dripping Sculptor", text: `<p class="mb-4">Deep underground, rainwater seeps through limestone rock, dissolving a mineral called calcite. Inside a cave, this water drips from the ceiling.</p><p>Each drop leaves a tiny deposit of calcite behind. Over thousands of years, these deposits grow into amazing rock formations called <strong>Stalactites</strong> (from the ceiling) and <strong>Stalagmites</strong> (from the floor).</p>`, sim: "caves" },
            { title: "The Endless Stone", text: `<p class="mb-4">The rocks beneath your feet are on an endless journey. Molten magma cools into <strong>Igneous</strong> rock. Wind and rain break it down into sand, which hardens into <strong>Sedimentary</strong> rock.</p><p>If buried and cooked by heat and pressure, it transforms into <strong>Metamorphic</strong> rock, which can melt and start the <strong>Rock Cycle</strong> all over again.</p>`, sim: "rockCycle" },
            { title: "The Earth's Hot Breath", text: `<p class="mb-4">In some places, underground water gets trapped near hot magma. The water boils, but the pressure from the rock above keeps it from turning to steam. It gets superheated!</p><p>Eventually, the pressure becomes too great, and a column of hot water and steam erupts into the air. This is a <strong>Geyser</strong>.</p>`, sim: "geyser" },
            { title: "The Light-Bender's Trick", text: `<p class="mb-4">Have you ever seen a <strong>Rainbow</strong> after a storm? It's a beautiful trick of light. When sunlight passes through a raindrop, the water acts like a tiny prism.</p><p>It bends the white light and splits it into all its different colors. This bending is called <strong>Refraction</strong>, and it paints a colorful arc across the sky.</p>`, sim: "rainbow" },
            { title: "The Sun's Fiery Breath", text: `<p class="mb-4">The Sun's surface is a tangled mess of powerful magnetic fields. Sometimes, these fields snap and reconnect, releasing a tremendous burst of energy.</p><p>This explosion, called a <strong>Solar Flare</strong>, sends a wave of radiation and charged particles hurtling through space at incredible speeds.</p>`, sim: "solarFlare" }
        ];

        const Book = {
            page: 0,
            init: function() { this.render(); },
            next: function() {
                this.page = (this.page < Stories.length - 1) ? this.page + 1 : 0;
                this.render();
            },
            prev: function() {
                if (this.page > 0) {
                    this.page--;
                    this.render();
                }
            },
            render: function() {
                const story = Stories[this.page];
                document.getElementById('story-title').textContent = story.title;
                document.getElementById('story-content').innerHTML = story.text;
                document.getElementById('btn-prev').disabled = this.page === 0;
                document.getElementById('btn-next').textContent = this.page === Stories.length - 1 ? "Restart Adventure" : "Next Adventure →";
                Simulations.load(story.sim);
            }
        };

        const Simulations = {
            animId: null, canvas: null, ctx: null, width: 0, height: 0, state: {},
            load: function(type) {
                if (this.animId) cancelAnimationFrame(this.animId);
                this.canvas = document.getElementById('sim-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.state = {};
                const dpr = window.devicePixelRatio || 1;
                const rect = this.canvas.parentElement.getBoundingClientRect();
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.width = rect.width;
                this.height = rect.height;
                if (this[type]) this[type].init(this);
            },
            solarSystem: {
                init: function(sim) {
                    sim.state.planets = [];
                    sim.state.stars = [];
                    for(let i=0; i<100; i++) sim.state.stars.push({ x: Math.random() * sim.width, y: Math.random() * sim.height, size: Math.random() * 2, alpha: Math.random() });
                    const colors = ['#9ca3af', '#d97706', '#3b82f6', '#ef4444', '#eab308', '#f59e0b'];
                    for(let i=0; i<6; i++) sim.state.planets.push({ r: 60 + i * 35, size: 4 + Math.random() * 8, speed: 0.02 - (i * 0.002), angle: Math.random() * Math.PI * 2, color: colors[i], trail: [] });
                    this.loop(sim);
                },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim;
                    const cx = width / 2, cy = height / 2;
                    ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, width, height);
                    ctx.fillStyle = '#fff';
                    state.stars.forEach(s => { ctx.globalAlpha = s.alpha + Math.sin(Date.now()/500)*0.2; ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill(); });
                    ctx.globalAlpha = 1;
                    const sunPulse = 20 + Math.sin(Date.now()/300) * 2;
                    const grad = ctx.createRadialGradient(cx, cy, 5, cx, cy, sunPulse * 2);
                    grad.addColorStop(0, '#fff'); grad.addColorStop(0.2, '#fcd34d'); grad.addColorStop(1, 'transparent');
                    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(cx, cy, sunPulse * 2, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#fbbf24'; ctx.beginPath(); ctx.arc(cx, cy, 15, 0, Math.PI*2); ctx.fill();
                    state.planets.forEach(p => {
                        p.angle += p.speed;
                        const x = cx + Math.cos(p.angle) * p.r, y = cy + Math.sin(p.angle) * p.r;
                        p.trail.push({x, y}); if (p.trail.length > 40) p.trail.shift();
                        ctx.beginPath(); ctx.strokeStyle = p.color; ctx.lineWidth = 2;
                        p.trail.forEach((pos, i) => { ctx.globalAlpha = i / 40; if (i===0) ctx.moveTo(pos.x, pos.y); else ctx.lineTo(pos.x, pos.y); });
                        ctx.stroke(); ctx.globalAlpha = 1;
                        ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(x, y, p.size, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.arc(x, y, p.size, p.angle + Math.PI/2, p.angle - Math.PI/2); ctx.fill();
                    });
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            photosynthesis: {
                init: function(sim) { sim.state.particles = []; this.loop(sim); },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim;
                    const grad = ctx.createLinearGradient(0, 0, 0, height);
                    grad.addColorStop(0, '#86efac'); grad.addColorStop(1, '#22c55e');
                    ctx.fillStyle = grad; ctx.fillRect(0, 0, width, height);
                    ctx.strokeStyle = '#16a34a'; ctx.lineWidth = 2;
                    for(let i=0; i<width; i+=50) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i + Math.sin(i)*10, height); ctx.stroke(); }
                    if (Math.random() < 0.1) state.particles.push({x: Math.random()*width, y: -10, vx: 0, vy: 2 + Math.random(), type: 'sun', r: 3});
                    if (Math.random() < 0.05) state.particles.push({x: -10, y: Math.random()*height, vx: 2, vy: (Math.random()-0.5), type: 'co2', r: 4});
                    if (Math.random() < 0.05) state.particles.push({x: Math.random()*width, y: height+10, vx: (Math.random()-0.5), vy: -2, type: 'h2o', r: 4});
                    for (let i = state.particles.length - 1; i >= 0; i--) {
                        let p = state.particles[i]; p.x += p.vx; p.y += p.vy;
                        const dx = p.x - width/2, dy = p.y - height/2;
                        if (Math.sqrt(dx*dx + dy*dy) < 50 && (p.type === 'sun' || p.type === 'co2' || p.type === 'h2o')) {
                            state.particles.splice(i, 1);
                            const newType = Math.random() > 0.5 ? 'o2' : 'sugar';
                            state.particles.push({x: width/2, y: height/2, vx: (Math.random()-0.5)*(newType==='o2'?3:1), vy: (Math.random()-0.5)*(newType==='o2'?3:1), type: newType, r: newType==='o2'?5:6, life: 100});
                            continue;
                        }
                        if (p.type === 'sun') ctx.fillStyle = '#facc15'; else if (p.type === 'co2') ctx.fillStyle = '#6b7280'; else if (p.type === 'h2o') ctx.fillStyle = '#3b82f6'; else if (p.type === 'o2') ctx.fillStyle = '#bae6fd'; else if (p.type === 'sugar') ctx.fillStyle = '#fff';
                        ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
                        if (p.x < -20 || p.x > width+20 || p.y < -20 || p.y > height+20) state.particles.splice(i, 1);
                    }
                    ctx.fillStyle = 'rgba(21, 128, 61, 0.8)'; ctx.beginPath(); ctx.ellipse(width/2, height/2, 60, 40, 0, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#86efac'; ctx.lineWidth = 3; ctx.stroke();
                    ctx.fillStyle = '#fff'; ctx.font = "12px sans-serif"; ctx.textAlign = "center"; ctx.fillText("Chloroplast", width/2, height/2 + 5);
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            earthquake: {
                init: function(sim) { sim.state = { offset: 0, shakeTime: 0, shockwaves: [] }; this.loop(sim); },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim;
                    ctx.fillStyle = '#854d0e'; ctx.fillRect(0, 0, width, height);
                    state.shakeTime++;
                    if (state.shakeTime > 200) {
                        state.offset = (Math.random() - 0.5) * 20;
                        if (state.shakeTime > 205) { state.shakeTime = 0; state.offset = 0; state.shockwaves.push({x: width/2, y: 150, r: 0}); }
                    } else { state.offset = Math.sin(state.shakeTime * 0.5) * 2; }
                    ctx.fillStyle = '#a16207'; ctx.fillRect(0, 0, width/2 - 2 + state.offset, height);
                    ctx.fillStyle = '#713f12'; ctx.fillRect(width/2 + 2 + state.offset, 0, width/2 - 2, height);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; ctx.lineWidth = 3;
                    for(let i = state.shockwaves.length - 1; i >= 0; i--) {
                        let w = state.shockwaves[i]; w.r += 5; ctx.globalAlpha = 1 - (w.r / 400);
                        ctx.beginPath(); ctx.arc(w.x, w.y, w.r, 0, Math.PI*2); ctx.stroke();
                        if (w.r > 400) state.shockwaves.splice(i, 1);
                    }
                    ctx.globalAlpha = 1;
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            volcano: {
                init: function(sim) { sim.state = { particles: [], magmaY: sim.height, lava: [] }; this.loop(sim); },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim;
                    ctx.fillStyle = '#6b7280'; ctx.fillRect(0, 0, width, height);
                    ctx.fillStyle = '#44403c'; ctx.beginPath(); ctx.moveTo(0, height); ctx.lineTo(width/2 - 50, 100); ctx.lineTo(width/2 + 50, 100); ctx.lineTo(width, height); ctx.fill();
                    if (state.magmaY > 100) state.magmaY -= 0.5;
                    ctx.fillStyle = '#f97316'; ctx.fillRect(width/2 - 10, state.magmaY, 20, height - state.magmaY);
                    if (state.magmaY <= 100) {
                        for(let i=0; i<5; i++) state.particles.push({ x: width/2, y: 100, vx: (Math.random()-0.5)*4, vy: -5-Math.random()*5, life: 100, color: Math.random()>0.3?'#57534e':'#f59e0b' });
                        if(Math.random()<0.3) state.lava.push({ x: width/2+(Math.random()-0.5)*40, y: 100 });
                    }
                    ctx.fillStyle = '#ef4444';
                    for(let i = state.lava.length - 1; i >= 0; i--) {
                        let l = state.lava[i]; l.x += l.x < width/2 ? -0.5 : 0.5; l.y += 2;
                        ctx.beginPath(); ctx.arc(l.x, l.y, 4, 0, Math.PI*2); ctx.fill();
                        if(l.y > height) state.lava.splice(i, 1);
                    }
                    for(let i = state.particles.length - 1; i >= 0; i--) {
                        let p = state.particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.1; p.life--;
                        ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 100;
                        ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2); ctx.fill();
                        if (p.life <= 0) state.particles.splice(i, 1);
                    }
                    ctx.globalAlpha = 1;
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            waterCycle: {
                init: function(sim) { sim.state = { particles: [], cloudSize: 20 }; this.loop(sim); },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim;
                    ctx.fillStyle = '#7dd3fc'; ctx.fillRect(0, 0, width, height);
                    ctx.fillStyle = '#075985'; ctx.fillRect(0, height - 50, width, 50);
                    ctx.fillStyle = '#fcd34d'; ctx.beginPath(); ctx.arc(50, 50, 30, 0, Math.PI*2); ctx.fill();
                    if (Math.random() < 0.5) state.particles.push({ x: Math.random() * width, y: height - 50, type: 'vapor', vx: (Math.random()-0.5)*0.5, vy: -1 });
                    if (state.cloudSize > 80 && Math.random() < 0.5) state.particles.push({ x: width/2-40+Math.random()*80, y: 100, type: 'rain', vy: 5 });
                    const cloudColor = Math.floor(255 - state.cloudSize);
                    ctx.fillStyle = `rgb(${cloudColor},${cloudColor},${cloudColor})`;
                    ctx.beginPath(); ctx.arc(width/2, 100, state.cloudSize, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(width/2-40, 100, state.cloudSize*0.8, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(width/2+40, 100, state.cloudSize*0.8, 0, Math.PI*2); ctx.fill();
                    for(let i = state.particles.length - 1; i >= 0; i--) {
                        let p = state.particles[i]; p.x += p.vx || 0; p.y += p.vy;
                        if (p.type === 'vapor') {
                            ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
                            if (p.y < 120) { state.particles.splice(i, 1); if(state.cloudSize < 100) state.cloudSize += 0.5; }
                        } else if (p.type === 'rain') {
                            ctx.strokeStyle = '#0ea5e9'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y-10); ctx.stroke();
                            if (p.y > height - 50) state.particles.splice(i, 1);
                        }
                    }
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            lightning: {
                init: function(sim) {
                    const { width, height } = sim; const cityscapePath = new Path2D(); cityscapePath.moveTo(0, height); cityscapePath.lineTo(0, height - 40);
                    for (let x = 0; x < width; x += 20) {
                        const buildingHeight = 40 + Math.random() * 80; const treeHeight = 30 + Math.random() * 40;
                        if (Math.random() > 0.4) { cityscapePath.lineTo(x, height - buildingHeight); cityscapePath.lineTo(x + 20, height - buildingHeight); }
                        else { cityscapePath.lineTo(x, height - 40); cityscapePath.lineTo(x + 10, height - 40 - treeHeight); cityscapePath.lineTo(x + 20, height - 40); }
                    }
                    cityscapePath.lineTo(width, height - 40); cityscapePath.lineTo(width, height); cityscapePath.closePath();
                    sim.state = { bolt: null, time: 0, cityscapePath: cityscapePath }; this.loop(sim);
                },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim; ctx.fillStyle = '#1e293b'; ctx.fillRect(0, 0, width, height);
                    ctx.fillStyle = '#0c0a09'; ctx.fill(state.cityscapePath);
                    ctx.fillStyle = '#475569'; ctx.beginPath(); ctx.ellipse(width/2, 80, 150, 50, 0, 0, Math.PI*2); ctx.fill();
                    state.time++;
                    if (state.time > 150 && !state.bolt) {
                        state.bolt = [{x: width/2, y: 130}];
                        for(let i=0; i<10; i++) { let last = state.bolt[state.bolt.length-1]; state.bolt.push({x: last.x + (Math.random()-0.5)*40, y: last.y + 20 + Math.random()*20}); }
                    }
                    if (state.time > 160) { state.bolt = null; state.time = 0; }
                    if (state.bolt) {
                        ctx.strokeStyle = '#fef08a'; ctx.lineWidth = 4; ctx.shadowColor = '#fef08a'; ctx.shadowBlur = 20;
                        ctx.beginPath(); state.bolt.forEach((p, i) => { if(i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y); }); ctx.stroke(); ctx.shadowBlur = 0;
                    } else {
                        ctx.fillStyle = '#f87171'; ctx.font = 'bold 16px sans-serif'; for(let i=0; i<10; i++) ctx.fillText('+', width/2-100+Math.random()*200, 60+Math.random()*20);
                        ctx.fillStyle = '#60a5fa'; for(let i=0; i<10; i++) ctx.fillText('-', width/2-100+Math.random()*200, 100+Math.random()*20);
                    }
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            aurora: {
                init: function(sim) { sim.state = { t: 0 }; this.loop(sim); },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim; state.t += 0.02;
                    ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, width, height);
                    ctx.fillStyle = '#fff'; for(let i=0; i<50; i++) { const x = (Math.sin(i*123)*10000)%width; const y = (Math.cos(i*456)*10000)%height; ctx.globalAlpha = 0.5+0.5*Math.sin(state.t+i); ctx.fillRect(Math.abs(x), Math.abs(y), 1.5, 1.5); }
                    ctx.globalAlpha = 1;
                    const drawCurtain = (color, offset, speed) => {
                        ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(0, height);
                        for (let x = 0; x <= width; x += 10) { const y = 50 + Math.sin(x*0.01+state.t*speed+offset)*50 + Math.sin(x*0.02+state.t*0.5)*30; ctx.lineTo(x, y); }
                        ctx.lineTo(width, height); ctx.fill();
                    };
                    ctx.globalCompositeOperation = 'screen'; 
                    const grad1 = ctx.createLinearGradient(0, 0, 0, height); grad1.addColorStop(0, 'rgba(74, 222, 128, 0)'); grad1.addColorStop(0.3, 'rgba(74, 222, 128, 0.6)'); grad1.addColorStop(1, 'rgba(74, 222, 128, 0)'); drawCurtain(grad1, 0, 1);
                    const grad2 = ctx.createLinearGradient(0, 0, 0, height); grad2.addColorStop(0, 'rgba(168, 85, 247, 0)'); grad2.addColorStop(0.4, 'rgba(168, 85, 247, 0.5)'); grad2.addColorStop(1, 'rgba(168, 85, 247, 0)'); drawCurtain(grad2, 2, 1.5);
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.fillStyle = '#020617'; ctx.beginPath(); ctx.moveTo(0, height); ctx.lineTo(0, height-60); ctx.lineTo(width*0.3, height-150); ctx.lineTo(width*0.6, height-80); ctx.lineTo(width, height-130); ctx.lineTo(width, height); ctx.fill();
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            tides: {
                init: function(sim) { sim.state = { time: 0 }; this.loop(sim); },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim; state.time += 0.005;
                    ctx.fillStyle = `hsl(210, 50%, ${50+40*Math.sin(state.time)})`; ctx.fillRect(0, 0, width, height);
                    const bodyX = (state.time*50)%(width+100)-50; const bodyY = height/2-Math.sin((bodyX+50)/(width+100)*Math.PI)*(height/2-20);
                    ctx.fillStyle = Math.sin(state.time)<0 ? '#e2e8f0' : '#fcd34d'; ctx.beginPath(); ctx.arc(bodyX, bodyY, 20, 0, Math.PI*2); ctx.fill();
                    const landHeight = 80; ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.moveTo(0, height-landHeight); ctx.bezierCurveTo(width*0.3, height-landHeight-20, width*0.7, height-landHeight+20, width, height-landHeight); ctx.lineTo(width, height); ctx.lineTo(0, height); ctx.closePath(); ctx.fill();
                    const tideLevel = (height-landHeight-10)+Math.cos(state.time*2)*30; ctx.fillStyle = 'rgba(59, 130, 246, 0.7)'; ctx.beginPath(); ctx.moveTo(0, tideLevel);
                    for (let x = 0; x < width; x++) ctx.lineTo(x, tideLevel+Math.sin(x*0.05+state.time*5)*3);
                    ctx.lineTo(width, height); ctx.lineTo(0, height); ctx.closePath(); ctx.fill();
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            blackHole: {
                init: function(sim) {
                    sim.state.particles = []; sim.state.stars = [];
                    for(let i=0; i<100; i++) sim.state.stars.push({ x: Math.random()*sim.width, y: Math.random()*sim.height, size: Math.random()*1.5, alpha: Math.random() });
                    this.loop(sim);
                },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim; const cx = width/2, cy = height/2;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; ctx.fillRect(0, 0, width, height);
                    ctx.fillStyle = '#fff'; state.stars.forEach(s => { ctx.globalAlpha = s.alpha; ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill(); });
                    ctx.globalAlpha = 1;
                    if (state.particles.length < 200) {
                        const angle = Math.random()*Math.PI*2; const dist = Math.max(width, height)*0.6;
                        state.particles.push({ x: cx+Math.cos(angle)*dist, y: cy+Math.sin(angle)*dist, vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2, angle: angle, dist: dist, speed: 1+Math.random() });
                    }
                    for (let i = state.particles.length - 1; i >= 0; i--) {
                        let p = state.particles[i]; p.dist -= p.speed; p.angle += 0.02 + (100/(p.dist+1))*0.001; p.speed += 0.05;
                        p.x = cx+Math.cos(p.angle)*p.dist; p.y = cy+Math.sin(p.angle)*p.dist;
                        const colorVal = Math.min(255, Math.floor(255*(200/p.dist))); ctx.fillStyle = `rgb(255, ${255-colorVal}, ${255-colorVal})`;
                        const size = Math.max(1, 3-(p.dist/200)); ctx.beginPath(); ctx.arc(p.x, p.y, size, 0, Math.PI*2); ctx.fill();
                        if (p.dist < 20) state.particles.splice(i, 1);
                    }
                    const grad = ctx.createRadialGradient(cx, cy, 20, cx, cy, 60); grad.addColorStop(0, 'rgba(255, 100, 0, 0.8)'); grad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(cx, cy, 60, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(cx, cy, 20, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 1; ctx.stroke();
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            meteorShower: {
                init: function(sim) {
                    sim.state.meteors = []; sim.state.stars = [];
                    for(let i=0; i<100; i++) sim.state.stars.push({ x: Math.random()*sim.width, y: Math.random()*sim.height, size: Math.random()*2, alpha: Math.random() });
                    this.loop(sim);
                },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim; ctx.fillStyle = 'rgba(15, 23, 42, 0.3)'; ctx.fillRect(0, 0, width, height);
                    ctx.fillStyle = '#fff'; state.stars.forEach(s => { ctx.globalAlpha = s.alpha; ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill(); });
                    ctx.globalAlpha = 1;
                    if (Math.random() < 0.1) state.meteors.push({ x: Math.random()*width*1.5, y: -50, vx: -5-Math.random()*5, vy: 3+Math.random()*5, len: 10+Math.random()*20, life: 1.0 });
                    ctx.strokeStyle = '#fff'; ctx.lineCap = 'round';
                    for (let i = state.meteors.length - 1; i >= 0; i--) {
                        let m = state.meteors[i]; m.x += m.vx; m.y += m.vy; m.life -= 0.02;
                        ctx.lineWidth = 2*m.life; ctx.globalAlpha = m.life; ctx.beginPath(); ctx.moveTo(m.x, m.y); ctx.lineTo(m.x-m.vx*3, m.y-m.vy*3); ctx.stroke();
                        if (m.life <= 0 || m.y > height || m.x < 0) state.meteors.splice(i, 1);
                    }
                    ctx.globalAlpha = 1; sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            mycelium: {
                init: function(sim) {
                    sim.state = { nodes: [], pulses: [] };
                    for(let i=0; i<6; i++) sim.state.nodes.push({ x: 40+i*(sim.width/6)+Math.random()*30, y: 280+Math.random()*100, connections: [] });
                    sim.state.nodes.forEach((n, i) => { sim.state.nodes.forEach((n2, j) => { if (i!==j && Math.sqrt((n.x-n2.x)**2+(n.y-n2.y)**2)<200 && Math.random()<0.5) n.connections.push(n2); }); });
                    this.loop(sim);
                },
                loop: function(sim) {
                    const { ctx, width, height, state } = sim; ctx.fillStyle = '#3f2e26'; ctx.fillRect(0, 0, width, height);
                    state.nodes.forEach(n => { ctx.strokeStyle = '#8b6b5d'; ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(n.x, n.y); ctx.quadraticCurveTo(n.x+(Math.random()-0.5)*10, n.y/2, n.x, 0); ctx.stroke(); ctx.fillStyle = '#a88d7b'; ctx.beginPath(); ctx.arc(n.x, n.y, 6, 0, Math.PI*2); ctx.fill(); });
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; ctx.lineWidth = 1;
                    state.nodes.forEach(n => { n.connections.forEach(n2 => { ctx.beginPath(); ctx.moveTo(n.x, n.y); ctx.quadraticCurveTo((n.x+n2.x)/2, (n.y+n2.y)/2+30, n2.x, n2.y); ctx.stroke(); }); });
                    if (Math.random() < 0.1) {
                        const start = state.nodes[Math.floor(Math.random()*state.nodes.length)];
                        if (start.connections.length > 0) state.pulses.push({ start: start, end: start.connections[Math.floor(Math.random()*start.connections.length)], progress: 0, speed: 0.02+Math.random()*0.02 });
                    }
                    ctx.fillStyle = '#86efac'; ctx.shadowColor = '#86efac'; ctx.shadowBlur = 5;
                    for (let i = state.pulses.length - 1; i >= 0; i--) {
                        let p = state.pulses[i]; p.progress += p.speed; const t = p.progress, invT = 1-t, cx = (p.start.x+p.end.x)/2, cy = (p.start.y+p.end.y)/2+30;
                        const x = invT*invT*p.start.x + 2*invT*t*cx + t*t*p.end.x; const y = invT*invT*p.start.y + 2*invT*t*cy + t*t*p.end.y;
                        ctx.beginPath(); ctx.arc(x, y, 2, 0, Math.PI*2); ctx.fill();
                        if (p.progress >= 1) state.pulses.splice(i, 1);
                    }
                    ctx.shadowBlur = 0; sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            pollination: {
                init: function(sim) {
                    sim.state = { bee: {x: 50, y: 100, target: 0}, flowers: [] };
                    for(let i=0; i<3; i++) sim.state.flowers.push({x: 200+i*150, y: 300});
                    this.loop(sim);
                },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim; ctx.fillStyle = '#87CEEB'; ctx.fillRect(0,0,width,height);
                    state.flowers.forEach(f => { ctx.fillStyle = '#228B22'; ctx.fillRect(f.x-2, f.y, 4, 50); ctx.fillStyle = '#FF69B4'; ctx.beginPath(); ctx.arc(f.x, f.y, 15, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(f.x, f.y, 5, 0, Math.PI*2); ctx.fill(); });
                    const target = state.flowers[state.bee.target]; const dx = target.x-state.bee.x, dy = (target.y-20)-state.bee.y, dist = Math.sqrt(dx*dx+dy*dy);
                    if(dist < 5) state.bee.target = (state.bee.target+1)%state.flowers.length;
                    else { state.bee.x += (dx/dist)*2; state.bee.y += (dy/dist)*2; }
                    ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(state.bee.x, state.bee.y, 8, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#000'; ctx.fillRect(state.bee.x-2, state.bee.y-8, 4, 16);
                    ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.beginPath(); ctx.ellipse(state.bee.x-5, state.bee.y-5, 8, 4, Math.sin(Date.now()/50), 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(state.bee.x+5, state.bee.y-5, 8, 4, -Math.sin(Date.now()/50), 0, Math.PI*2); ctx.fill();
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            metamorphosis: {
                init: function(sim) { sim.state = { stage: 0, timer: 0, x: 50 }; this.loop(sim); },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim; ctx.fillStyle = '#728FCE'; ctx.fillRect(0,0,width,height);
                    const time = Date.now()/500; for(let i=0; i<width; i+=15) { ctx.fillStyle = '#22c55e'; const h = 40+Math.sin(i*0.1+time)*10; ctx.beginPath(); ctx.moveTo(i, height); ctx.quadraticCurveTo(i+5, height-h/2, i+Math.sin(time*2+i)*5, height-h); ctx.lineTo(i+10, height); ctx.fill(); }
                    ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 10; ctx.beginPath(); ctx.moveTo(0, 200); ctx.lineTo(width, 200); ctx.stroke();
                    state.timer++; if(state.timer > 200) { state.stage = (state.stage+1)%4; state.timer = 0; state.x = 50; }
                    if(state.stage === 0) { ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(width/2, 195, 5, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#000'; ctx.fillText("Egg", width/2-10, 180); }
                    else if(state.stage === 1) { state.x += 0.5; ctx.fillStyle = '#7CFC00'; for(let i=0; i<5; i++) { ctx.beginPath(); ctx.arc(state.x+i*10, 190+Math.sin(state.timer*0.2+i)*2, 6, 0, Math.PI*2); ctx.fill(); } ctx.fillStyle = '#000'; ctx.fillText("Larva", state.x, 170); }
                    else if(state.stage === 2) { ctx.fillStyle = '#8FBC8F'; ctx.beginPath(); ctx.ellipse(width/2, 210, 10, 20, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#000'; ctx.fillText("Pupa", width/2-15, 240); }
                    else { state.x += 2; const y = 150+Math.sin(state.timer*0.1)*30; ctx.fillStyle = '#FFA500'; ctx.beginPath(); ctx.moveTo(state.x, y); ctx.lineTo(state.x-15, y-15); ctx.lineTo(state.x-15, y+15); ctx.fill(); ctx.beginPath(); ctx.moveTo(state.x, y); ctx.lineTo(state.x+15, y-15); ctx.lineTo(state.x+15, y+15); ctx.fill(); ctx.fillStyle = '#000'; ctx.fillRect(state.x-2, y-10, 4, 20); ctx.fillText("Butterfly", state.x-20, y-30); }
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            seedDispersal: {
                init: function(sim) { sim.state = { seeds: [] }; this.loop(sim); },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim; ctx.fillStyle = '#87CEEB'; ctx.fillRect(0,0,width,height); ctx.fillStyle = '#228B22'; ctx.fillRect(0, height-20, width, 20);
                    ctx.strokeStyle = '#228B22'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(100, height-20); ctx.lineTo(100, height-150); ctx.stroke();
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(100, height-150, 10, 0, Math.PI*2); ctx.fill();
                    if(Math.random() < 0.05) state.seeds.push({x: 100, y: height-150, vx: 1+Math.random(), vy: -0.5+Math.random()});
                    state.seeds.forEach((s, i) => { s.x += s.vx; s.y += s.vy; ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(s.x-5, s.y-5); ctx.stroke(); ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(s.x-5, s.y+5); ctx.stroke(); if(s.x > width) state.seeds.splice(i, 1); });
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            coralReef: {
                init: function(sim) {
                    sim.state = { fish: [], bubbles: [], corals: [], time: 0 };
                    for(let i=0; i<15; i++) sim.state.fish.push({ x: Math.random()*sim.width, y: Math.random()*(sim.height-100), vx: (Math.random()-0.5)*3, color: `hsl(${Math.random()*360}, 80%, 60%)`, size: 5+Math.random()*8 });
                    const numCorals = Math.floor(sim.width/15);
                    for(let i=0; i<numCorals; i++) sim.state.corals.push({ x: i*15+Math.random()*5, h: 40+Math.random()*60, color: `hsl(${Math.random()*60+300}, 70%, ${40+Math.random()*20}%)`, type: Math.random()>0.5?'round':'branch' });
                    this.loop(sim);
                },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim; state.time += 0.02;
                    const grad = ctx.createLinearGradient(0, 0, 0, height); grad.addColorStop(0, '#00b4db'); grad.addColorStop(1, '#0083b0'); ctx.fillStyle = grad; ctx.fillRect(0,0,width,height);
                    state.corals.forEach((c, i) => { ctx.fillStyle = c.color; const sway = Math.sin(state.time+i*0.5)*5; if (c.type === 'round') { ctx.beginPath(); ctx.ellipse(c.x, height, 10, c.h/2, 0, Math.PI, 0); ctx.fill(); } else { ctx.beginPath(); ctx.moveTo(c.x, height); ctx.quadraticCurveTo(c.x+sway, height-c.h/2, c.x+sway*1.5, height-c.h); ctx.lineWidth = 4; ctx.strokeStyle = c.color; ctx.stroke(); } });
                    if (Math.random() < 0.05) state.bubbles.push({ x: Math.random()*width, y: height, r: Math.random()*3+1, v: Math.random()*1+0.5 });
                    for (let i = state.bubbles.length - 1; i >= 0; i--) { let b = state.bubbles[i]; b.y -= b.v; b.x += Math.sin(b.y*0.05)*0.5; ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'; ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill(); if (b.y < 0) state.bubbles.splice(i, 1); }
                    state.fish.forEach(f => { f.x += f.vx; if(f.x < -20) f.x = width+20; if(f.x > width+20) f.x = -20; ctx.save(); ctx.translate(f.x, f.y); if (f.vx < 0) ctx.scale(-1, 1); ctx.fillStyle = f.color; ctx.beginPath(); ctx.ellipse(0, 0, f.size, f.size/1.5, 0, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.moveTo(-f.size/2, 0); ctx.lineTo(-f.size-5, -5); ctx.lineTo(-f.size-5, 5); ctx.fill(); ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(f.size/2, -2, 2, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(f.size/2+1, -2, 1, 0, Math.PI*2); ctx.fill(); ctx.restore(); });
                    ctx.save(); ctx.globalCompositeOperation = 'overlay'; const rayGrad = ctx.createLinearGradient(0, 0, 0, height); rayGrad.addColorStop(0, 'rgba(255, 255, 255, 0.1)'); rayGrad.addColorStop(1, 'rgba(255, 255, 255, 0)'); ctx.fillStyle = rayGrad; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(width, 0); ctx.lineTo(width*0.8, height); ctx.lineTo(width*0.2, height); ctx.fill(); ctx.restore();
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            fireflies: {
                init: function(sim) { sim.state = { flies: [] }; for(let i=0; i<30; i++) sim.state.flies.push({ x: Math.random()*sim.width, y: Math.random()*sim.height, t: Math.random()*100 }); this.loop(sim); },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim; ctx.fillStyle = '#020617'; ctx.fillRect(0,0,width,height);
                    state.flies.forEach(f => { f.x += (Math.random()-0.5); f.y += (Math.random()-0.5); f.t += 0.1; const alpha = (Math.sin(f.t)+1)/2; ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`; ctx.beginPath(); ctx.arc(f.x, f.y, 3, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 10; ctx.shadowColor = 'yellow'; ctx.fill(); ctx.shadowBlur = 0; });
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            fossil: {
                init: function(sim) { sim.state = { sedimentH: 0 }; this.loop(sim); },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim; ctx.fillStyle = '#87CEEB'; ctx.fillRect(0, 0, width, height); ctx.fillStyle = '#5D4037'; ctx.fillRect(0, height-40, width, 40);
                    const fossilFactor = Math.min(1, Math.max(0, (state.sedimentH-30)/100)); const boneColor = `rgb(${255-(255-78)*fossilFactor},${255-(255-52)*fossilFactor},${255-(255-46)*fossilFactor})`;
                    ctx.save(); ctx.translate(width/2, height-45); ctx.strokeStyle = boneColor; ctx.lineWidth = 4; ctx.lineCap = 'round'; ctx.fillStyle = boneColor;
                    ctx.beginPath(); ctx.moveTo(-40, 0); ctx.quadraticCurveTo(0, -10, 50, 5); ctx.stroke(); for(let i=-20; i<20; i+=8) { ctx.beginPath(); ctx.moveTo(i, -5); ctx.lineTo(i, 5); ctx.stroke(); } ctx.beginPath(); ctx.moveTo(-40, 0); ctx.lineTo(-55, -5); ctx.lineTo(-60, 5); ctx.lineTo(-45, 5); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(-20, 0); ctx.lineTo(-25, 20); ctx.stroke(); ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(25, 20); ctx.stroke(); ctx.restore();
                    if (state.sedimentH < height-40) state.sedimentH += 0.5;
                    let currentY = height-40, remaining = state.sedimentH; const layers = [{h: 40, c: 'rgba(121, 85, 72, 0.7)'}, {h: 40, c: 'rgba(141, 110, 99, 0.7)'}, {h: 60, c: 'rgba(161, 136, 127, 0.8)'}, {h: 200, c: 'rgba(62, 39, 35, 0.9)'}];
                    layers.forEach(l => { if (remaining > 0) { const h = Math.min(remaining, l.h); ctx.fillStyle = l.c; ctx.fillRect(0, currentY-h, width, h); currentY -= h; remaining -= h; } });
                    ctx.fillStyle = '#000'; ctx.font = '14px sans-serif'; ctx.fillText(fossilFactor<0.2?"Burial...":fossilFactor<0.8?"Pressure & Time...":"Fossilized!", 10, 30);
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            caves: {
                init: function(sim) { sim.state = { h: 0, dropY: 0 }; this.loop(sim); },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim; ctx.fillStyle = '#2c2c2c'; ctx.fillRect(0,0,width,height);
                    if(state.h < 100) state.h += 0.1;
                    ctx.fillStyle = '#d3d3d3'; ctx.beginPath(); ctx.moveTo(width/2-20, 0); ctx.lineTo(width/2+20, 0); ctx.lineTo(width/2, state.h); ctx.fill(); ctx.beginPath(); ctx.moveTo(width/2-20, height); ctx.lineTo(width/2+20, height); ctx.lineTo(width/2, height-state.h); ctx.fill();
                    state.dropY += 5; if(state.dropY > height) state.dropY = state.h;
                    ctx.fillStyle = '#00f'; ctx.beginPath(); ctx.arc(width/2, state.dropY, 3, 0, Math.PI*2); ctx.fill();
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            rockCycle: {
                init: function(sim) { sim.state = { angle: 0 }; this.loop(sim); },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim; ctx.fillStyle = '#FAB972'; ctx.fillRect(0,0,width,height);
                    state.angle += 0.01; const cx = width/2, cy = height/2, r = 100, types = ['Magma', 'Igneous', 'Sediment', 'Sedimentary', 'Metamorphic'], colors = ['#f00', '#555', '#eec', '#d2b48c', '#708090'];
                    types.forEach((t, i) => { const a = state.angle+(i*Math.PI*2/types.length), x = cx+Math.cos(a)*r, y = cy+Math.sin(a)*r; ctx.fillStyle = colors[i]; ctx.beginPath(); ctx.arc(x, y, 30, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#000'; ctx.textAlign = 'center'; ctx.fillText(t, x, y+40); });
                    ctx.strokeStyle = '#000'; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            geyser: {
                init: function(sim) { sim.state = { pressure: 0, erupting: false, particles: [] }; this.loop(sim); },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim; ctx.fillStyle = '#87CEEB'; ctx.fillRect(0,0,width,height); ctx.fillStyle = '#8B4513'; ctx.fillRect(0, height-50, width, 50);
                    if(!state.erupting) { state.pressure += 1; if(state.pressure > 200) state.erupting = true; }
                    else { state.pressure -= 2; if(state.pressure < 0) state.erupting = false; for(let i=0; i<5; i++) state.particles.push({ x: width/2, y: height-50, vy: -5-Math.random()*5, vx: (Math.random()-0.5)*2 }); }
                    for(let i=state.particles.length-1; i>=0; i--) { let p = state.particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.1; ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill(); if(p.y > height) state.particles.splice(i, 1); }
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            rainbow: {
                init: function(sim) { sim.state = { t: 0 }; this.loop(sim); },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim; state.t += 0.01; ctx.fillStyle = '#111827'; ctx.fillRect(0, 0, width, height);
                    const cx = width/2.5, cy = height/2, size = 120, hTri = size*Math.sqrt(3)/2, p1 = {x: cx, y: cy-hTri/2-20}, p2 = {x: cx-size/2, y: cy+hTri/2-20}, p3 = {x: cx+size/2, y: cy+hTri/2-20};
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.05)'; ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.lineTo(p3.x, p3.y); ctx.closePath(); ctx.fill(); ctx.stroke();
                    const entryT = 0.6+Math.sin(state.t)*0.1, entryX = p1.x+(p2.x-p1.x)*entryT, entryY = p1.y+(p2.y-p1.y)*entryT;
                    ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(0, entryY+50); ctx.lineTo(entryX, entryY); ctx.stroke();
                    const colors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3'];
                    colors.forEach((col, i) => { ctx.strokeStyle = col; ctx.lineWidth = 5; ctx.globalAlpha = 0.8; const exitT = entryT+0.1+(i*0.015), exitX = p1.x+(p3.x-p1.x)*exitT, exitY = p1.y+(p3.y-p1.y)*exitT; ctx.beginPath(); ctx.moveTo(entryX, entryY); ctx.lineTo(exitX, exitY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(exitX, exitY); ctx.lineTo(width, exitY+(exitY-entryY)*2+(i*30)); ctx.stroke(); });
                    ctx.globalAlpha = 1; ctx.fillStyle = '#fff'; ctx.font = '14px sans-serif'; ctx.textAlign = 'center'; ctx.fillText("Prism Refraction", cx, cy+100);
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            snowflake: {
                init: function(sim) { sim.state = { len: 0 }; this.loop(sim); },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim; ctx.fillStyle = '#1e3a8a'; ctx.fillRect(0,0,width,height); if(state.len < 100) state.len += 0.5;
                    const drawFlake = (x, y, scale) => { ctx.save(); ctx.translate(x, y); ctx.scale(scale, scale); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; for(let i=0; i<6; i++) { ctx.rotate(Math.PI/3); ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0, state.len); ctx.stroke(); if(state.len > 20) { ctx.beginPath(); ctx.moveTo(0, 20); ctx.lineTo(10, 30); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, 20); ctx.lineTo(-10, 30); ctx.stroke(); } if(state.len > 50) { ctx.beginPath(); ctx.moveTo(0, 50); ctx.lineTo(20, 70); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, 50); ctx.lineTo(-20, 70); ctx.stroke(); } } ctx.restore(); };
                    drawFlake(width/2-80, height/2-80, 1); drawFlake(width/2+120, height/2+80, 0.7);
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            solarFlare: {
                init: function(sim) { sim.state = { t: 0, flares: [], particles: [], surfaceNoise: [] }; for(let i=0; i<100; i++) sim.state.surfaceNoise.push({ x: Math.random()*Math.PI*2, y: Math.random()*Math.PI, size: Math.random()*5+2, alpha: Math.random()*0.5+0.2 }); this.loop(sim); },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim; const cx = width/2, cy = height/2, sunRadius = 100; state.t += 0.05; ctx.fillStyle = '#000000'; ctx.fillRect(0, 0, width, height);
                    const gradient = ctx.createRadialGradient(cx, cy, sunRadius, cx, cy, sunRadius*3); gradient.addColorStop(0, 'rgba(255, 100, 0, 0.8)'); gradient.addColorStop(0.2, 'rgba(255, 50, 0, 0.4)'); gradient.addColorStop(1, 'rgba(255, 0, 0, 0)'); ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(cx, cy, sunRadius*3, 0, Math.PI*2); ctx.fill();
                    const sunGrad = ctx.createRadialGradient(cx, cy, sunRadius*0.2, cx, cy, sunRadius); sunGrad.addColorStop(0, '#FDB813'); sunGrad.addColorStop(0.8, '#FF8C00'); sunGrad.addColorStop(1, '#FF4500'); ctx.fillStyle = sunGrad; ctx.beginPath(); ctx.arc(cx, cy, sunRadius, 0, Math.PI*2); ctx.fill();
                    ctx.save(); ctx.beginPath(); ctx.arc(cx, cy, sunRadius, 0, Math.PI*2); ctx.clip(); state.surfaceNoise.forEach(n => { const px = cx+Math.cos(n.x+state.t*0.02)*(n.y/Math.PI)*sunRadius, py = cy+Math.sin(n.x+state.t*0.02)*(n.y/Math.PI)*sunRadius*0.8; ctx.fillStyle = `rgba(255, 200, 0, ${n.alpha})`; ctx.beginPath(); ctx.arc(px, py, n.size, 0, Math.PI*2); ctx.fill(); }); ctx.restore();
                    if (Math.random() < 0.02) state.flares.push({ angle: Math.random()*Math.PI*2, life: 0, maxLife: 100+Math.random()*100, scale: 0.5+Math.random()*1.5 });
                    for (let i = state.flares.length - 1; i >= 0; i--) {
                        let f = state.flares[i]; f.life++; const growth = Math.sin((f.life/f.maxLife)*Math.PI), h = 60*f.scale*growth;
                        const x1 = cx+Math.cos(f.angle-0.1)*sunRadius, y1 = cy+Math.sin(f.angle-0.1)*sunRadius, x2 = cx+Math.cos(f.angle+0.1)*sunRadius, y2 = cy+Math.sin(f.angle+0.1)*sunRadius;
                        ctx.strokeStyle = `rgba(255, 200, 100, ${growth})`; ctx.lineWidth = 3*growth; ctx.beginPath(); ctx.moveTo(x1, y1); ctx.quadraticCurveTo(cx+Math.cos(f.angle)*(sunRadius+h*2), cy+Math.sin(f.angle)*(sunRadius+h*2), x2, y2); ctx.stroke();
                        if (f.life/f.maxLife > 0.4 && f.life/f.maxLife < 0.6 && Math.random()<0.3) state.particles.push({ x: cx+Math.cos(f.angle)*(sunRadius+h), y: cy+Math.sin(f.angle)*(sunRadius+h), vx: Math.cos(f.angle)*(2+Math.random()), vy: Math.sin(f.angle)*(2+Math.random()), life: 60 });
                        if (f.life >= f.maxLife) state.flares.splice(i, 1);
                    }
                    for (let i = state.particles.length - 1; i >= 0; i--) { let p = state.particles[i]; p.x += p.vx; p.y += p.vy; p.life--; ctx.fillStyle = `rgba(255, 255, 200, ${p.life/60})`; ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2); ctx.fill(); if (p.life <= 0) state.particles.splice(i, 1); }
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            },
            migration: {
                init: function(sim) { sim.state = { birds: [] }; for(let i=0; i<20; i++) sim.state.birds.push({ x: -Math.random()*100, y: 50+Math.random()*200, speed: 2+Math.random(), offset: Math.random()*10 }); this.loop(sim); },
                loop: function(sim) {
                    const {ctx, width, height, state} = sim; ctx.fillStyle = '#87CEEB'; ctx.fillRect(0,0,width,height); ctx.fillStyle = '#228B22'; ctx.beginPath(); ctx.arc(width/2, height+200, 300, 0, Math.PI*2); ctx.fill();
                    const t = Date.now()/100; state.birds.forEach(b => { b.x += b.speed; if(b.x > width+20) b.x = -20; ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(b.x-6, b.y+Math.sin(t*2+b.offset)*5); ctx.lineTo(b.x, b.y); ctx.lineTo(b.x+6, b.y+Math.sin(t*2+b.offset)*5); ctx.stroke(); });
                    sim.animId = requestAnimationFrame(() => this.loop(sim));
                }
            }
        };

        window.onload = function() { Book.init(); };
    </script>
</body>
</html>