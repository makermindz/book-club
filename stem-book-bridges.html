<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Bridge Master's Handbook - A STEM Adventure</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'green-primary': '#2980b9', /* Changed to Blue for Engineering theme */
                        'green-secondary': '#3498db',
                        'green-light': '#f0f8ff',
                        'brand-dark': '#2c3e50',
                        'paper': '#fdfbf7',
                    },
                    fontFamily: {
                        sans: ['Segoe UI', 'Tahoma', 'Geneva', 'Verdana', 'sans-serif'],
                        serif: ['Georgia', 'Cambria', 'Times New Roman', 'Times', 'serif'],
                    },
                    boxShadow: {
                        'book': '0 20px 30px -10px rgba(0, 0, 0, 0.3), 0 0 10px rgba(0,0,0,0.1)',
                        'page': 'inset 0 0 30px rgba(0,0,0,0.05)',
                    }
                }
            }
        }
    </script>
    <style>
        body {
            background-color: #2c3e50;
            background-image: radial-gradient(#34495e 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        .book-container {
            perspective: 1500px;
        }

        .book-page {
            transition: transform 0.8s cubic-bezier(0.645, 0.045, 0.355, 1);
            transform-style: preserve-3d;
            transform-origin: left center;
        }

        .page-content {
            backface-visibility: hidden;
        }

        /* Simulation Canvas Styles */
        canvas {
            border-radius: 0.5rem;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
            background-color: #fff;
            cursor: pointer;
        }

        .sim-control-panel {
            background: #f0f8ff;
            border: 1px solid #3498db;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
        }

        /* Custom Range Slider */
        input[type=range] {
            height: 6px;
            background: #e2e8f0;
            border-radius: 5px;
            outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #2980b9;
            cursor: pointer;
        }
    </style>
</head>
<body class="h-screen flex items-center justify-center overflow-hidden">

    <div class="book-container w-full max-w-5xl h-[90vh] relative flex items-center justify-center">
        
        <!-- Book Spine/Back -->
        <div class="absolute inset-0 bg-brand-dark rounded-r-2xl shadow-2xl transform translate-x-2 translate-y-2"></div>

        <!-- Active Page Container -->
        <div id="book-page" class="book-page relative w-full h-full bg-paper rounded-r-xl shadow-book flex flex-col md:flex-row overflow-hidden border-l-8 border-gray-200">
            
            <!-- Left Side: Story & Text -->
            <div class="w-full md:w-1/3 p-8 md:p-12 flex flex-col justify-center border-r border-gray-100 bg-white relative">
                <div class="absolute top-0 left-0 w-full h-2 bg-gradient-to-r from-green-primary to-green-secondary"></div>
                
                <div class="mb-4 text-green-primary font-bold uppercase tracking-widest text-xs">
                    Page <span id="page-num">1</span> of <span id="total-pages">24</span>
                </div>
                
                <h2 id="story-title" class="text-3xl font-serif font-bold text-brand-dark mb-6 leading-tight"></h2>
                
                <div id="story-text" class="prose text-gray-600 leading-relaxed mb-8 text-sm overflow-y-auto max-h-[40vh] pr-2">
                    <!-- Story content injected here -->
                </div>

                <div class="mt-auto flex gap-4">
                    <button onclick="Book.prevPage()" id="btn-prev" class="flex-1 px-4 py-3 rounded-lg border-2 border-gray-200 text-gray-500 font-bold hover:border-brand-dark hover:text-brand-dark transition disabled:opacity-30 disabled:cursor-not-allowed">
                        ‚Üê Previous
                    </button>
                    <button onclick="Book.nextPage()" id="btn-next" class="flex-1 px-4 py-3 rounded-lg bg-green-primary text-white font-bold hover:bg-green-secondary shadow-lg transition transform hover:-translate-y-1 disabled:opacity-50 disabled:cursor-not-allowed">
                        Next Page ‚Üí
                    </button>
                </div>
            </div>

            <!-- Right Side: Interactive Simulation -->
            <div class="w-full md:w-2/3 bg-green-light relative p-6 flex flex-col items-center justify-center">
                <div class="absolute top-4 right-4 text-gray-500 text-s font-sans z-20">
                    &copy; Maker Mindz
                </div>
                <div class="absolute top-6 right-6 text-brand-dark opacity-10 text-9xl font-serif font-bold select-none">
                    üåâ
                </div>
                
                <div id="sim-container" class="w-full max-w-2xl z-10">
                    <div class="bg-white p-2 rounded-xl shadow-lg border border-gray-200">
                        <canvas id="sim-canvas" width="600" height="350" class="w-full h-auto bg-gray-50 rounded-lg"></canvas>
                    </div>
                    
                    <div id="sim-controls" class="sim-control-panel shadow-sm min-h-[80px] flex flex-col justify-center">
                        <!-- Controls injected here -->
                    </div>
                    
                    <div id="sim-feedback" class="mt-3 text-center font-bold text-brand-dark min-h-[1.5rem]"></div>
                </div>
            </div>

        </div>
    </div>

    <script>
        // --- BOOK CONTENT & LOGIC ---
        
        const Pages = [
            {
                title: "The Bridge Master's Handbook",
                text: "Welcome, Apprentice! You are about to embark on a journey through the art and science of Bridge Engineering. From simple logs to massive steel giants, bridges connect our world. Are you ready to earn your title as a Master Builder?",
                simType: "cover",
                instruction: "Click 'Next Page' to begin your training."
            },
            {
                title: "The Problem: The Gap",
                text: "Every bridge starts with a problem: a gap. It could be a river, a canyon, or a highway. Before we build, we must understand the obstacle. Here lies the Great Chasm of Ignorance. We must cross it!",
                simType: "gap",
                instruction: "Click the screen to survey the gap."
            },
            {
                title: "Nature's Bridge",
                text: "The simplest bridge is a beam. Nature invented it first - a fallen tree across a stream. It works, but it has limits. If the gap is too wide, the log will bend and break under its own weight.",
                simType: "log",
                instruction: "Click to drop a log across the chasm."
            },
            {
                title: "The Beam Bridge",
                text: "Engineers refined the log into the Beam Bridge. It consists of a horizontal beam supported at each end by piers. When a load pushes down, the beam bends. The top edge is squeezed, and the bottom edge is stretched.",
                simType: "beam",
                instruction: "Use the slider to apply load and see the beam bend."
            },
            {
                title: "Forces: Compression & Tension",
                text: "To build strong bridges, you must master two forces. <b>Compression</b> is a squeezing force (pushing together). <b>Tension</b> is a stretching force (pulling apart). Different materials handle these forces differently.",
                simType: "forces",
                instruction: "Hover over the block to see the forces in action."
            },
            {
                title: "Summary: Beam Basics",
                text: "Beam bridges are simple and inexpensive but limited in span. The farther apart the piers, the weaker the beam becomes. To span wider gaps, we need better designs.",
                simType: "beam_static",
                instruction: "Review the diagram."
            },
            {
                title: "The Truss: Triangles are Strong",
                text: "Why do bridges have so many triangles? A square can easily distort into a rhombus under pressure. A triangle, however, is rigid. It cannot change shape without breaking one of its sides.",
                simType: "shapes",
                instruction: "Click the shapes to apply force and test rigidity."
            },
            {
                title: "Building a Truss",
                text: "By connecting triangles, we create a Truss. This structure distributes the weight of the load across many steel members, allowing the bridge to span greater distances than a simple beam.",
                simType: "truss",
                instruction: "Hover over the truss members to see if they are in Compression (Red) or Tension (Blue)."
            },
            {
                title: "Summary: Trusses",
                text: "Truss bridges are incredibly efficient, using less material to carry heavy loads. They are the workhorses of the railway world.",
                simType: "truss_static",
                instruction: "Review the truss design."
            },
            {
                title: "The Arch Bridge",
                text: "The Romans were masters of the Arch. An arch bridge works by transferring the weight of the bridge and its load partially into a horizontal thrust restrained by the abutments at either side.",
                simType: "arch",
                instruction: "Click to apply load and watch the force travel down the arch."
            },
            {
                title: "The Keystone",
                text: "The most important stone in an arch is the Keystone at the very top. It locks all the other stones in place. Without it, the arch collapses.",
                simType: "keystone",
                instruction: "Drag the Keystone into the center to lock the arch."
            },
            {
                title: "Summary: Arches",
                text: "Arch bridges are always in compression. Stone and concrete are great for arches because they are strong under compression but weak under tension.",
                simType: "arch_static",
                instruction: "Admire the stability of the arch."
            },
            {
                title: "The Suspension Bridge",
                text: "To span the widest gaps, we use Suspension Bridges. Giant cables are draped over tall towers and anchored deep into the ground. The deck hangs from these cables.",
                simType: "suspension",
                instruction: "Adjust the cable sag with the slider."
            },
            {
                title: "Tension in the Cables",
                text: "The main cables are in massive tension. They pull on the anchorages with thousands of tons of force. The towers support the weight, standing in compression.",
                simType: "suspension_tension",
                instruction: "Increase the deck weight and watch the tension rise."
            },
            {
                title: "Summary: Suspension",
                text: "Suspension bridges are light, flexible, and beautiful. They can span distances no other bridge type can, like the Golden Gate Bridge.",
                simType: "suspension_static",
                instruction: "Review the suspension design."
            },
            {
                title: "Cable-Stayed Bridges",
                text: "A modern variation is the Cable-Stayed bridge. Instead of one main cable, multiple cables run directly from the tower to the deck. It forms a fan-like pattern.",
                simType: "cablestay",
                instruction: "Click to toggle between 'Harp' and 'Fan' cable arrangements."
            },
            {
                title: "Resonance & Wind",
                text: "Bridges must fight the wind. If the wind pushes at the bridge's natural frequency, it can cause resonance - violent shaking that can destroy the bridge (like the Tacoma Narrows).",
                simType: "resonance",
                instruction: "Adjust the wind speed. Avoid the 'Danger Zone' frequency!"
            },
            {
                title: "Materials Science",
                text: "Engineers choose materials carefully. Concrete is cheap and strong in compression. Steel is expensive but strong in tension. Reinforced concrete combines both!",
                simType: "materials",
                instruction: "Click 'Test' to crush the concrete block."
            },
            {
                title: "Foundations & Piers",
                text: "A bridge is only as strong as its foundation. If the riverbed is soft mud, engineers drive long poles called 'piles' deep into the earth until they hit solid rock.",
                simType: "piles",
                instruction: "Click to hammer the pile into the ground."
            },
            {
                title: "Cantilever Bridges",
                text: "A cantilever is a beam supported only on one end, like a diving board. Cantilever bridges use two arms reaching out from opposite sides to meet in the middle.",
                simType: "cantilever",
                instruction: "Balance the cantilever arms by adding weight to the anchor arms."
            },
            {
                title: "Moveable Bridges",
                text: "Sometimes, boats need to pass. Bascule bridges (drawbridges) use a counterweight to lift the heavy deck with very little energy.",
                simType: "bascule",
                instruction: "Drag the slider to raise the bridge for the ship."
            },
            {
                title: "The Load Test",
                text: "You've learned the principles. Now, test your bridge! We will drive heavy trucks onto the deck. Will your design hold, or will it crumble?",
                simType: "load_test",
                instruction: "Click 'Add Truck' to test the limit."
            },
            {
                title: "Future Bridges",
                text: "The future of bridging is exciting! Engineers are designing floating bridges, 3D-printed bridges, and even bridges that heal their own cracks with bacteria.",
                simType: "future",
                instruction: "Watch the autonomous 3D printer construct the bridge."
            },
            {
                title: "Master Builder",
                text: "Congratulations! You have completed the handbook. You understand forces, materials, and designs. Go forth and connect the world!",
                simType: "certificate",
                instruction: "Click to receive your seal."
            }
        ];

        const Book = {
            currentPage: 0,
            
            init: function() {
                this.renderPage();
            },

            nextPage: function() {
                if (this.currentPage < Pages.length - 1) {
                    this.currentPage++;
                    this.renderPage();
                } else {
                    this.currentPage = 0;
                    this.renderPage();
                }
            },

            prevPage: function() {
                if (this.currentPage > 0) {
                    this.currentPage--;
                    this.renderPage();
                }
            },

            renderPage: function() {
                const page = Pages[this.currentPage];
                
                // Update Text
                document.getElementById('page-num').textContent = this.currentPage + 1;
                document.getElementById('total-pages').textContent = Pages.length;
                document.getElementById('story-title').textContent = page.title;
                document.getElementById('story-text').innerHTML = `<p>${page.text}</p><p class="mt-4 text-sm font-bold text-green-primary italic">Task: ${page.instruction}</p>`;
                
                // Update Buttons
                document.getElementById('btn-prev').disabled = this.currentPage === 0;
                document.getElementById('btn-next').disabled = false;
                if (this.currentPage === Pages.length - 1) {
                    document.getElementById('btn-next').textContent = "Restart";
                } else {
                    document.getElementById('btn-next').textContent = "Next Page ‚Üí";
                }

                // Load Simulation
                Simulations.load(page.simType);
            }
        };

        const Simulations = {
            canvas: null,
            ctx: null,
            animId: null,
            activeType: null,
            state: {},

            load: function(type) {
                if (this.animId) cancelAnimationFrame(this.animId);
                this.activeType = type;
                this.canvas = document.getElementById('sim-canvas');
                this.canvas.onmousemove = null;
                this.canvas.onmousedown = null;
                this.canvas.onmouseup = null;
                this.canvas.onclick = null;
                this.ctx = this.canvas.getContext('2d');
                
                // Reset controls
                document.getElementById('sim-controls').innerHTML = '';
                document.getElementById('sim-feedback').textContent = '';
                document.getElementById('sim-feedback').className = "mt-3 text-center font-bold text-brand-dark min-h-[1.5rem]";

                // Initialize specific simulation
                if (this[type]) this[type].init(this);
                else this.placeholder.init(this);
            },

            placeholder: {
                init: function(sim) {
                    sim.ctx.clearRect(0,0,600,350);
                    sim.ctx.fillStyle = "#bdc3c7";
                    sim.ctx.font = "20px sans-serif";
                    sim.ctx.textAlign = "center";
                    sim.ctx.fillText("Static Diagram / Visual", 300, 175);
                }
            },

            // 1. COVER
            cover: {
                init: function(sim) {
                    sim.state = { t: 0 };
                    sim.loop = () => {
                        const ctx = sim.ctx;
                        sim.state.t += 0.02;
                        ctx.fillStyle = '#2c3e50';
                        ctx.fillRect(0, 0, 600, 350);
                        
                        // Draw Bridge Silhouette
                        ctx.fillStyle = '#34495e';
                        ctx.beginPath();
                        ctx.moveTo(0, 350);
                        ctx.lineTo(100, 250);
                        ctx.lineTo(500, 250);
                        ctx.lineTo(600, 350);
                        ctx.fill();

                        // Draw Suspension Cables
                        ctx.strokeStyle = '#f1c40f';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(100, 250);
                        ctx.quadraticCurveTo(300, 350, 500, 250);
                        ctx.stroke();

                        // Title
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 40px serif'; ctx.textAlign = 'center';
                        ctx.fillText("Bridge Engineering", 300, 150);
                        
                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 2. GAP
            gap: {
                init: function(sim) {
                    const ctx = sim.ctx;
                    ctx.clearRect(0,0,600,350);
                    // Sky
                    ctx.fillStyle = '#87CEEB'; ctx.fillRect(0,0,600,350);
                    // Cliffs
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(0, 200, 150, 150);
                    ctx.fillRect(450, 200, 150, 150);
                    // Water
                    ctx.fillStyle = '#3498db';
                    ctx.fillRect(150, 300, 300, 50);
                    
                    document.getElementById('sim-feedback').textContent = "Gap Width: 300 meters";
                    function draw() {
                        ctx.clearRect(0,0,600,350);
                        // Sky
                        ctx.fillStyle = '#87CEEB'; ctx.fillRect(0,0,600,350);
                        // Cliffs
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(0, 200, 150, 150);
                        ctx.fillRect(450, 200, 150, 150);
                        // Water
                        ctx.fillStyle = '#3498db';
                        ctx.fillRect(150, 300, 300, 50);
                    }
                    draw();
                    
                    document.getElementById('sim-feedback').textContent = "Click to survey.";
                    
                    sim.canvas.onclick = () => {
                        draw();
                        // Draw measurement line
                        ctx.strokeStyle = '#2c3e50';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(150, 200);
                        ctx.lineTo(450, 200);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Draw arrows
                        ctx.fillStyle = '#2c3e50';
                        ctx.beginPath(); ctx.moveTo(150, 200); ctx.lineTo(160, 195); ctx.lineTo(160, 205); ctx.fill();
                        ctx.beginPath(); ctx.moveTo(450, 200); ctx.lineTo(440, 195); ctx.lineTo(440, 205); ctx.fill();

                        document.getElementById('sim-feedback').textContent = "Gap Width: 300 meters";
                        document.getElementById('sim-feedback').className = "mt-3 text-center font-bold text-green-primary min-h-[1.5rem]";
                    };
                }
            },

            // 3. LOG
            log: {
                init: function(sim) {
                    sim.state = { dropped: false, y: 0 };
                    sim.canvas.onclick = () => sim.state.dropped = true;
                    
                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        // Background (same as gap)
                        ctx.fillStyle = '#87CEEB'; ctx.fillRect(0,0,600,350);
                        ctx.fillStyle = '#8B4513'; ctx.fillRect(0, 200, 150, 150); ctx.fillRect(450, 200, 150, 150);
                        
                        if(sim.state.dropped && sim.state.y < 200) sim.state.y += 5;

                        if(sim.state.dropped) {
                            ctx.fillStyle = '#5D4037';
                            ctx.fillRect(100, sim.state.y, 400, 20); // The Log
                        } else {
                            ctx.fillStyle = '#5D4037';
                            ctx.fillRect(50, 180, 20, 100); // Tree standing
                            ctx.fillStyle = '#27ae60';
                            ctx.beginPath(); ctx.arc(60, 180, 30, 0, Math.PI*2); ctx.fill();
                        }
                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 4. BEAM
            beam: {
                init: function(sim) {
                    sim.state = { load: 0 };
                    document.getElementById('sim-controls').innerHTML = `
                        <div class="flex items-center gap-4"><span class="font-bold">Load:</span><input type="range" min="0" max="100" value="0" class="flex-1" oninput="Simulations.state.load=parseInt(this.value)"></div>
                    `;
                    
                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        // Piers
                        ctx.fillStyle = '#7f8c8d';
                        ctx.fillRect(100, 250, 20, 100);
                        ctx.fillRect(480, 250, 20, 100);

                        // Beam
                        const bend = sim.state.load * 0.8;
                        ctx.fillStyle = '#e74c3c';
                        ctx.beginPath();
                        ctx.moveTo(100, 250);
                        ctx.quadraticCurveTo(300, 250 + bend, 500, 250);
                        ctx.lineTo(500, 270);
                        ctx.quadraticCurveTo(300, 270 + bend, 100, 270);
                        ctx.fill();

                        // Load Arrow
                        if(sim.state.load > 0) {
                            ctx.fillStyle = '#2c3e50';
                            ctx.fillRect(290, 150 + bend/2, 20, 80);
                            ctx.beginPath(); ctx.moveTo(280, 230 + bend/2); ctx.lineTo(320, 230 + bend/2); ctx.lineTo(300, 250 + bend/2); ctx.fill();
                        }
                        
                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 5. FORCES
            forces: {
                init: function(sim) {
                    sim.state = { hovering: false };
                    sim.canvas.onmousemove = (e) => {
                        const rect = sim.canvas.getBoundingClientRect();
                        const mx = e.clientX - rect.left;
                        const my = e.clientY - rect.top;
                        sim.state.hovering = (mx > 200 && mx < 400 && my > 125 && my < 225);
                    };

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        const offset = sim.state.hovering ? Math.sin(Date.now() / 150) * 5 : 0;

                        // Block
                        ctx.fillStyle = '#3498db';
                        ctx.strokeStyle = '#2980b9'; ctx.lineWidth = 2;
                        
                        if (sim.state.hovering) {
                            ctx.beginPath();
                            ctx.moveTo(200 + offset, 125); ctx.lineTo(400 - offset, 125);
                            ctx.lineTo(400 + offset, 225); ctx.lineTo(200 - offset, 225);
                            ctx.closePath(); ctx.fill(); ctx.stroke();
                        } else {
                            ctx.fillRect(200, 125, 200, 100);
                            ctx.strokeRect(200, 125, 200, 100);
                        }

                        // Compression (Top)
                        ctx.fillStyle = '#e74c3c';
                        ctx.font = 'bold 16px sans-serif'; ctx.textAlign = 'center'; ctx.fillText("Compression (Squeeze)", 300, 100);
                        ctx.beginPath(); ctx.moveTo(220 + offset, 140); ctx.lineTo(280 + offset, 140); ctx.lineTo(270 + offset, 135); ctx.moveTo(280 + offset, 140); ctx.lineTo(270 + offset, 145); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(380 - offset, 140); ctx.lineTo(320 - offset, 140); ctx.lineTo(330 - offset, 135); ctx.moveTo(320 - offset, 140); ctx.lineTo(330 - offset, 145); ctx.stroke();

                        // Tension (Bottom)
                        ctx.fillStyle = '#27ae60';
                        ctx.fillText("Tension (Stretch)", 300, 260);
                        ctx.beginPath(); ctx.moveTo(280 - offset, 210); ctx.lineTo(220 - offset, 210); ctx.lineTo(230 - offset, 205); ctx.moveTo(220 - offset, 210); ctx.lineTo(230 - offset, 215); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(320 + offset, 210); ctx.lineTo(380 + offset, 210); ctx.lineTo(370 + offset, 205); ctx.moveTo(380 + offset, 210); ctx.lineTo(370 + offset, 215); ctx.stroke();

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 7. SHAPES
            shapes: {
                init: function(sim) {
                    sim.state = { offset: 0 };
                    sim.canvas.onmousedown = (e) => {
                        const rect = sim.canvas.getBoundingClientRect();
                        const mx = e.clientX - rect.left;
                        const my = e.clientY - rect.top;
                        // Only distort if clicking the square (approx bounds 100,100 to 200,200)
                        if (mx > 100 && mx < 200 && my > 100 && my < 200) sim.state.offset = 20;
                    };
                    sim.canvas.onmouseup = () => sim.state.offset = 0;

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        const off = sim.state.offset;

                        // Square
                        ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 4;
                        ctx.beginPath(); 
                        ctx.moveTo(100 + off, 100); ctx.lineTo(200 + off, 100); // Top moves
                        ctx.lineTo(200, 200); ctx.lineTo(100, 200); ctx.closePath();
                        ctx.stroke();
                        ctx.fillStyle = '#000'; ctx.fillText("Square (Unstable)", 150, 230);

                        // Triangle
                        ctx.strokeStyle = '#27ae60';
                        ctx.beginPath();
                        ctx.moveTo(400, 100); ctx.lineTo(450, 200); ctx.lineTo(350, 200); ctx.closePath();
                        ctx.stroke();
                        ctx.fillText("Triangle (Rigid)", 400, 230);

                        // Hand pushing
                        if(off > 0) {
                            ctx.fillStyle = '#f1c40f'; ctx.fillText("PUSH!", 150, 80);
                        }

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 8. TRUSS
            truss: {
                init: function(sim) {
                    sim.state = { hoverMember: null };
                    
                    const members = [
                        { p1: {x:150, y:150}, p2: {x:450, y:150}, type: 'compression', label: 'Top Chord' },
                        { p1: {x:100, y:250}, p2: {x:500, y:250}, type: 'tension', label: 'Bottom Chord' },
                        { p1: {x:100, y:250}, p2: {x:150, y:150}, type: 'compression', label: 'Diagonal' },
                        { p1: {x:150, y:150}, p2: {x:200, y:250}, type: 'tension', label: 'Diagonal' },
                        { p1: {x:200, y:250}, p2: {x:250, y:150}, type: 'compression', label: 'Diagonal' },
                        { p1: {x:250, y:150}, p2: {x:300, y:250}, type: 'tension', label: 'Diagonal' },
                        { p1: {x:300, y:250}, p2: {x:350, y:150}, type: 'compression', label: 'Diagonal' },
                        { p1: {x:350, y:150}, p2: {x:400, y:250}, type: 'tension', label: 'Diagonal' },
                        { p1: {x:400, y:250}, p2: {x:450, y:150}, type: 'compression', label: 'Diagonal' },
                        { p1: {x:450, y:150}, p2: {x:500, y:250}, type: 'tension', label: 'Diagonal' }
                    ];

                    function distToSegment(p, v, w) {
                        const l2 = (w.x - v.x)**2 + (w.y - v.y)**2;
                        if (l2 === 0) return Math.sqrt((p.x - v.x)**2 + (p.y - v.y)**2);
                        let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
                        t = Math.max(0, Math.min(1, t));
                        return Math.sqrt((p.x - (v.x + t * (w.x - v.x)))**2 + (p.y - (v.y + t * (w.y - v.y)))**2);
                    }

                    sim.canvas.onmousemove = (e) => {
                        const rect = sim.canvas.getBoundingClientRect();
                        const mx = e.clientX - rect.left;
                        const my = e.clientY - rect.top;
                        
                        let found = null;
                        for(let m of members) {
                            if (distToSegment({x:mx, y:my}, m.p1, m.p2) < 10) {
                                found = m;
                                break;
                            }
                        }
                        sim.state.hoverMember = found;
                    };

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        // Supports
                        ctx.fillStyle = '#7f8c8d';
                        ctx.fillRect(90, 250, 20, 100);
                        ctx.fillRect(490, 250, 20, 100);

                        ctx.lineWidth = 8;
                        ctx.lineCap = 'round';

                        members.forEach(m => {
                            const isHovered = sim.state.hoverMember === m;
                            ctx.beginPath();
                            ctx.moveTo(m.p1.x, m.p1.y);
                            ctx.lineTo(m.p2.x, m.p2.y);
                            if (isHovered) {
                                ctx.strokeStyle = m.type === 'compression' ? '#e74c3c' : '#3498db';
                            } else {
                                ctx.strokeStyle = '#95a5a6';
                            }
                            ctx.stroke();
                        });

                        ctx.fillStyle = '#2c3e50';
                        const joints = [
                            {x:100, y:250}, {x:150, y:150}, {x:200, y:250}, {x:250, y:150},
                            {x:300, y:250}, {x:350, y:150}, {x:400, y:250}, {x:450, y:150}, {x:500, y:250}
                        ];
                        joints.forEach(j => {
                            ctx.beginPath(); ctx.arc(j.x, j.y, 6, 0, Math.PI*2); ctx.fill();
                        });

                        if (sim.state.hoverMember) {
                            const m = sim.state.hoverMember;
                            const typeText = m.type === 'compression' ? "Compression (Squeeze)" : "Tension (Stretch)";
                            document.getElementById('sim-feedback').textContent = `${m.label}: ${typeText}`;
                            document.getElementById('sim-feedback').className = `mt-3 text-center font-bold ${m.type === 'compression' ? 'text-red-500' : 'text-blue-500'} min-h-[1.5rem]`;
                        } else {
                            document.getElementById('sim-feedback').textContent = "Hover over members to see forces.";
                            document.getElementById('sim-feedback').className = "mt-3 text-center font-bold text-brand-dark min-h-[1.5rem]";
                        }

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 10. ARCH
            arch: {
                init: function(sim) {
                    sim.state = { load: false, chariotX: 50 };
                    sim.canvas.onclick = () => sim.state.load = !sim.state.load;

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        // Sky
                        ctx.fillStyle = '#87CEEB'; ctx.fillRect(0,0,600,350);
                        // Ground/Water
                        ctx.fillStyle = '#3498db'; ctx.fillRect(150, 300, 300, 50); // Water
                        ctx.fillStyle = '#27ae60'; ctx.fillRect(0, 300, 150, 50); ctx.fillRect(450, 300, 150, 50); // Banks

                        // Abutments
                        ctx.fillStyle = '#7f8c8d'; 
                        ctx.fillRect(50, 150, 100, 150); 
                        ctx.fillRect(450, 150, 100, 150);
                        
                        // Labels for Abutments
                        ctx.fillStyle = '#2c3e50';
                        ctx.font = 'bold 14px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText("Abutment", 100, 320);
                        ctx.fillText("Abutment", 500, 320);

                        // Arch
                        ctx.strokeStyle = '#7f8c8d'; ctx.lineWidth = 20;
                        ctx.beginPath(); ctx.arc(300, 300, 150, Math.PI, 0); ctx.stroke();

                        // Fill (Spandrels)
                        ctx.fillStyle = '#bdc3c7';
                        ctx.beginPath();
                        ctx.moveTo(150, 150);
                        ctx.lineTo(450, 150);
                        ctx.lineTo(450, 300);
                        ctx.arc(300, 300, 150, 0, Math.PI, true); 
                        ctx.lineTo(150, 300);
                        ctx.closePath();
                        ctx.fill();

                        // Platform (Deck)
                        ctx.fillStyle = '#7f8c8d';
                        ctx.fillRect(50, 140, 500, 10); 

                        // Roman Chariot
                        sim.state.chariotX = (sim.state.chariotX + 1) % 500;
                        if (sim.state.chariotX < 50) sim.state.chariotX = 50;
                        
                        const cx = sim.state.chariotX;
                        const cy = 140; 

                        ctx.save();
                        ctx.translate(cx, cy);
                        
                        // Wheel
                        ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.arc(0, -10, 10, 0, Math.PI*2); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(0, -20); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(10, -10); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(0, 0); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(-10, -10); ctx.stroke();

                        // Body
                        ctx.fillStyle = '#c0392b';
                        ctx.fillRect(-15, -25, 30, 15);
                        
                        // Horse
                        ctx.fillStyle = '#8d6e63';
                        ctx.fillRect(20, -20, 25, 15); 
                        ctx.fillRect(40, -30, 10, 15); 
                        ctx.fillRect(20, -5, 5, 10); 
                        ctx.fillRect(40, -5, 5, 10); 

                        // Driver
                        ctx.fillStyle = '#f1c40f';
                        ctx.beginPath(); ctx.arc(0, -30, 5, 0, Math.PI*2); ctx.fill();
                        ctx.fillRect(-5, -25, 10, 10);

                        ctx.restore();

                        if(sim.state.load) {
                            // Force Vectors
                            ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 3;
                            
                            // Draw forces traveling down the arch
                            const segments = 8;
                            for (let i = 0; i < segments; i++) {
                                // Left side: 270 deg (1.5 PI) down to 180 deg (PI)
                                let startAngle = 1.5 * Math.PI - (i / segments) * 0.5 * Math.PI;
                                let endAngle = 1.5 * Math.PI - ((i + 0.6) / segments) * 0.5 * Math.PI;
                                
                                let x1 = 300 + Math.cos(startAngle) * 150;
                                let y1 = 300 + Math.sin(startAngle) * 150;
                                let x2 = 300 + Math.cos(endAngle) * 150;
                                let y2 = 300 + Math.sin(endAngle) * 150;
                                
                                ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
                                // Arrowhead
                                let angle = Math.atan2(y2 - y1, x2 - x1);
                                ctx.beginPath(); ctx.moveTo(x2, y2); 
                                ctx.lineTo(x2 - 10 * Math.cos(angle - Math.PI / 6), y2 - 10 * Math.sin(angle - Math.PI / 6));
                                ctx.moveTo(x2, y2);
                                ctx.lineTo(x2 - 10 * Math.cos(angle + Math.PI / 6), y2 - 10 * Math.sin(angle + Math.PI / 6));
                                ctx.stroke();

                                // Right side: 270 deg (1.5 PI) down to 360 deg (2 PI)
                                startAngle = 1.5 * Math.PI + (i / segments) * 0.5 * Math.PI;
                                endAngle = 1.5 * Math.PI + ((i + 0.6) / segments) * 0.5 * Math.PI;
                                
                                x1 = 300 + Math.cos(startAngle) * 150;
                                y1 = 300 + Math.sin(startAngle) * 150;
                                x2 = 300 + Math.cos(endAngle) * 150;
                                y2 = 300 + Math.sin(endAngle) * 150;
                                
                                ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
                                // Arrowhead
                                angle = Math.atan2(y2 - y1, x2 - x1);
                                ctx.beginPath(); ctx.moveTo(x2, y2); 
                                ctx.lineTo(x2 - 10 * Math.cos(angle - Math.PI / 6), y2 - 10 * Math.sin(angle - Math.PI / 6));
                                ctx.moveTo(x2, y2);
                                ctx.lineTo(x2 - 10 * Math.cos(angle + Math.PI / 6), y2 - 10 * Math.sin(angle + Math.PI / 6));
                                ctx.stroke();
                            }

                            // Left Thrust
                            ctx.beginPath(); ctx.moveTo(150, 300); ctx.lineTo(100, 300); ctx.lineTo(110, 290); ctx.moveTo(100, 300); ctx.lineTo(110, 310); ctx.stroke();
                            ctx.fillStyle = '#e74c3c';
                            ctx.fillText("Thrust", 100, 280);

                            // Right Thrust
                            ctx.beginPath(); ctx.moveTo(450, 300); ctx.lineTo(500, 300); ctx.lineTo(490, 290); ctx.moveTo(500, 300); ctx.lineTo(490, 310); ctx.stroke();
                            ctx.fillText("Thrust", 500, 280);
                            
                            // Load from Chariot
                            ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx, cy+40); 
                            ctx.lineTo(cx-5, cy+35); ctx.moveTo(cx, cy+40); ctx.lineTo(cx+5, cy+35); ctx.stroke();

                            document.getElementById('sim-feedback').textContent = "Arch directs load outward as Thrust.";
                        } else {
                            document.getElementById('sim-feedback').textContent = "Click to see forces.";
                        }

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 11. KEYSTONE
            keystone: {
                init: function(sim) {
                    sim.state = { ky: 50, dragging: false };
                    
                    sim.canvas.onmousedown = (e) => {
                        if(Math.abs(e.clientX - sim.canvas.getBoundingClientRect().left - 300) < 30) sim.state.dragging = true;
                    };
                    sim.canvas.onmousemove = (e) => {
                        if(sim.state.dragging) sim.state.ky = Math.max(50, Math.min(150, e.clientY - sim.canvas.getBoundingClientRect().top));
                    };
                    sim.canvas.onmouseup = () => sim.state.dragging = false;

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        // Arch sides
                        ctx.fillStyle = '#95a5a6';
                        ctx.beginPath(); ctx.moveTo(150, 300); ctx.lineTo(250, 180); ctx.lineTo(270, 200); ctx.lineTo(200, 300); ctx.fill();
                        ctx.beginPath(); ctx.moveTo(450, 300); ctx.lineTo(350, 180); ctx.lineTo(330, 200); ctx.lineTo(400, 300); ctx.fill();

                        // Keystone
                        ctx.fillStyle = '#e74c3c';
                        const ky = sim.state.ky;
                        ctx.beginPath(); ctx.moveTo(280, ky); ctx.lineTo(320, ky); ctx.lineTo(310, ky+40); ctx.lineTo(290, ky+40); ctx.fill();

                        if(ky >= 140) document.getElementById('sim-feedback').textContent = "Arch Locked!";
                        else document.getElementById('sim-feedback').textContent = "Lower the Keystone.";

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 13. SUSPENSION
            suspension: {
                init: function(sim) {
                    sim.state = { sag: 50 };
                    document.getElementById('sim-controls').innerHTML = `
                        <div class="flex items-center gap-4"><span class="font-bold">Cable Sag:</span><input type="range" min="20" max="150" value="50" class="flex-1" oninput="Simulations.state.sag=parseInt(this.value)"></div>
                    `;

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        // Towers
                        ctx.fillStyle = '#34495e';
                        ctx.fillRect(100, 50, 20, 250);
                        ctx.fillRect(480, 50, 20, 250);
                        
                        // Deck
                        ctx.fillStyle = '#95a5a6';
                        ctx.fillRect(0, 250, 600, 10);

                        // Main Cable
                        ctx.strokeStyle = '#e67e22'; ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(110, 50);
                        ctx.quadraticCurveTo(300, 50 + sim.state.sag * 2, 490, 50);
                        ctx.stroke();

                        // Suspenders
                        ctx.lineWidth = 1;
                        for(let x=130; x<480; x+=20) {
                            // Calculate y of parabola at x
                            // y = a(x-h)^2 + k. Vertex (300, 50+sag*2)
                            // 50 = a(110-300)^2 + k => a approx
                            const t = (x - 110) / 380;
                            // Simple lerp for visual
                            // Bezier point calculation
                            const y = (1-t)*(1-t)*50 + 2*(1-t)*t*(50+sim.state.sag*2) + t*t*50;
                            
                            ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, 250); ctx.stroke();
                        }

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 14. TENSION
            suspension_tension: {
                init: function(sim) {
                    sim.state = { weight: 1 };
                    document.getElementById('sim-controls').innerHTML = `
                        <div class="flex items-center gap-4"><span class="font-bold">Deck Weight:</span><input type="range" min="1" max="10" value="1" class="flex-1" oninput="Simulations.state.weight=parseInt(this.value)"></div>
                    `;

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        // Tower
                        ctx.fillStyle = '#34495e'; ctx.fillRect(290, 50, 20, 250);
                        
                        // Cable
                        const tension = sim.state.weight * 2;
                        ctx.strokeStyle = tension > 15 ? '#e74c3c' : '#27ae60';
                        ctx.lineWidth = 3 + sim.state.weight/2;
                        ctx.beginPath(); ctx.moveTo(300, 50); ctx.lineTo(50, 250); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(300, 50); ctx.lineTo(550, 250); ctx.stroke();

                        document.getElementById('sim-feedback').textContent = `Cable Tension: ${tension * 1000} Tons`;

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 16. CABLE STAYED
            cablestay: {
                init: function(sim) {
                    sim.state = { type: 'fan' };
                    sim.canvas.onclick = () => sim.state.type = sim.state.type === 'fan' ? 'harp' : 'fan';

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        // Tower
                        ctx.fillStyle = '#34495e'; ctx.fillRect(290, 50, 20, 250);
                        // Deck
                        ctx.fillRect(50, 250, 500, 10);

                        ctx.strokeStyle = '#f39c12'; ctx.lineWidth = 2;
                        
                        if (sim.state.type === 'fan') {
                            for(let i=0; i<5; i++) {
                                ctx.beginPath(); ctx.moveTo(300, 60); ctx.lineTo(100 + i*40, 250); ctx.stroke();
                                ctx.beginPath(); ctx.moveTo(300, 60); ctx.lineTo(500 - i*40, 250); ctx.stroke();
                            }
                            document.getElementById('sim-feedback').textContent = "Fan Design: Cables connect to top of tower.";
                        } else {
                            for(let i=0; i<5; i++) {
                                ctx.beginPath(); ctx.moveTo(300, 60 + i*30); ctx.lineTo(100 + i*40, 250); ctx.stroke();
                                ctx.beginPath(); ctx.moveTo(300, 60 + i*30); ctx.lineTo(500 - i*40, 250); ctx.stroke();
                            }
                            document.getElementById('sim-feedback').textContent = "Harp Design: Cables are parallel.";
                        }

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 17. RESONANCE
            resonance: {
                init: function(sim) {
                    sim.state = { wind: 0, t: 0 };
                    document.getElementById('sim-controls').innerHTML = `
                        <div class="flex items-center gap-4"><span class="font-bold">Wind Speed:</span><input type="range" min="0" max="10" value="0" class="flex-1" oninput="Simulations.state.wind=parseInt(this.value)"></div>
                    `;

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        sim.state.t += 0.1;

                        const amp = (sim.state.wind === 5) ? 40 : sim.state.wind * 2; // Resonance at wind=5
                        
                        ctx.strokeStyle = '#34495e'; ctx.lineWidth = 5;
                        ctx.beginPath();
                        for(let x=50; x<550; x++) {
                            const y = 175 + Math.sin(x*0.02 + sim.state.t) * amp;
                            if(x===50) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                        }
                        ctx.stroke();

                        if(sim.state.wind === 5) {
                            document.getElementById('sim-feedback').textContent = "DANGER! RESONANCE DETECTED!";
                            document.getElementById('sim-feedback').className = "mt-3 text-center font-bold text-red-600 animate-pulse";
                        } else {
                            document.getElementById('sim-feedback').textContent = "Stable.";
                            document.getElementById('sim-feedback').className = "mt-3 text-center font-bold text-brand-dark";
                        }

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 18. MATERIALS
            materials: {
                init: function(sim) {
                    sim.state = { crushed: false };
                    const btn = document.createElement('button');
                    btn.className = "px-4 py-2 bg-blue-600 text-white rounded font-bold";
                    btn.textContent = "Test Concrete";
                    btn.onclick = () => sim.state.crushed = true;
                    document.getElementById('sim-controls').appendChild(btn);

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        // Press
                        const pressY = sim.state.crushed ? 200 : 100;
                        ctx.fillStyle = '#2c3e50'; ctx.fillRect(250, 0, 100, pressY);

                        // Block
                        if(sim.state.crushed) {
                            ctx.fillStyle = '#95a5a6';
                            ctx.beginPath(); ctx.moveTo(250, 300); ctx.lineTo(350, 300); ctx.lineTo(360, 280); ctx.lineTo(240, 280); ctx.fill();
                            document.getElementById('sim-feedback').textContent = "Concrete crumbled under tension/shear!";
                        } else {
                            ctx.fillStyle = '#bdc3c7';
                            ctx.fillRect(250, 200, 100, 100);
                            document.getElementById('sim-feedback').textContent = "Concrete Block Ready.";
                        }

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 19. PILES
            piles: {
                init: function(sim) {
                    sim.state = { depth: 0 };
                    sim.canvas.onclick = () => { if(sim.state.depth < 150) sim.state.depth += 10; };

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        // Water
                        ctx.fillStyle = '#3498db'; ctx.fillRect(0, 100, 600, 100);
                        // Mud
                        ctx.fillStyle = '#795548'; ctx.fillRect(0, 200, 600, 100);
                        // Rock
                        ctx.fillStyle = '#424242'; ctx.fillRect(0, 300, 600, 50);

                        // Pile
                        ctx.fillStyle = '#ecf0f1';
                        ctx.fillRect(280, 100, 40, 100 + sim.state.depth);
                        
                        // Hammer
                        ctx.fillStyle = '#e74c3c';
                        ctx.fillRect(270, 50 + (Math.sin(Date.now()/100)*20), 60, 40);

                        if(sim.state.depth >= 100) document.getElementById('sim-feedback').textContent = "Hit Bedrock! Foundation Secure.";
                        else document.getElementById('sim-feedback').textContent = "Click to drive pile deeper.";

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 20. CANTILEVER
            cantilever: {
                init: function(sim) {
                    sim.state = { weight: 0 };
                    document.getElementById('sim-controls').innerHTML = `
                        <div class="flex items-center gap-4"><span class="font-bold">Counterweight:</span><input type="range" min="0" max="100" value="0" class="flex-1" oninput="Simulations.state.weight=parseInt(this.value)"></div>
                    `;

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        // Pier
                        ctx.fillStyle = '#7f8c8d'; ctx.fillRect(280, 200, 40, 150);

                        // Arm
                        ctx.save();
                        ctx.translate(300, 200);
                        const angle = (50 - sim.state.weight) * 0.005; // Balance logic
                        ctx.rotate(angle);
                        ctx.fillStyle = '#e67e22'; ctx.fillRect(-150, -10, 300, 20);
                        ctx.restore();

                        if(Math.abs(angle) < 0.05) document.getElementById('sim-feedback').textContent = "Balanced!";
                        else document.getElementById('sim-feedback').textContent = "Unbalanced.";

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 21. BASCULE
            bascule: {
                init: function(sim) {
                    sim.state = { angle: 0 };
                    document.getElementById('sim-controls').innerHTML = `
                        <div class="flex items-center gap-4"><span class="font-bold">Lift:</span><input type="range" min="0" max="45" value="0" class="flex-1" oninput="Simulations.state.angle=parseInt(this.value)"></div>
                    `;

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        // Water
                        ctx.fillStyle = '#3498db'; ctx.fillRect(0, 300, 600, 50);
                        // Piers
                        ctx.fillStyle = '#7f8c8d'; ctx.fillRect(100, 250, 50, 100); ctx.fillRect(450, 250, 50, 100);

                        // Left Leaf
                        ctx.save();
                        ctx.translate(150, 250);
                        ctx.rotate(-sim.state.angle * Math.PI/180);
                        ctx.fillStyle = '#2c3e50'; ctx.fillRect(0, -10, 150, 20);
                        ctx.restore();

                        // Right Leaf
                        ctx.save();
                        ctx.translate(450, 250);
                        ctx.rotate(sim.state.angle * Math.PI/180);
                        ctx.fillStyle = '#2c3e50'; ctx.fillRect(-150, -10, 150, 20);
                        ctx.restore();

                        // Ship
                        if(sim.state.angle > 30) {
                            ctx.fillStyle = '#e74c3c';
                            ctx.fillRect(280, 280, 40, 20);
                            ctx.fillRect(290, 260, 20, 20);
                            document.getElementById('sim-feedback').textContent = "Ship Passing.";
                        } else {
                            document.getElementById('sim-feedback').textContent = "Bridge Closed.";
                        }

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 22. LOAD TEST
            load_test: {
                init: function(sim) {
                    sim.state = { cars: 0, broken: false };
                    const btn = document.createElement('button');
                    btn.className = "px-4 py-2 bg-green-600 text-white rounded font-bold";
                    btn.textContent = "Add Truck (10 Tons)";
                    btn.onclick = () => {
                        if(!sim.state.broken) sim.state.cars++;
                        if(sim.state.cars > 5) sim.state.broken = true;
                    };
                    document.getElementById('sim-controls').appendChild(btn);

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        // Bridge
                        if(sim.state.broken) {
                            ctx.beginPath(); ctx.moveTo(0, 200); ctx.lineTo(300, 300); ctx.lineTo(600, 200);
                            ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 10; ctx.stroke();
                            document.getElementById('sim-feedback').textContent = "BRIDGE COLLAPSED! Too heavy.";
                        } else {
                            ctx.beginPath(); ctx.moveTo(0, 200); ctx.lineTo(600, 200);
                            ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 10; ctx.stroke();
                            
                            // Draw Cars
                            ctx.fillStyle = '#f1c40f';
                            for(let i=0; i<sim.state.cars; i++) {
                                ctx.fillRect(50 + i*80, 180, 40, 20);
                            }
                            document.getElementById('sim-feedback').textContent = `Load: ${sim.state.cars * 10} Tons`;
                        }

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 23. FUTURE
            future: {
                init: function(sim) {
                    sim.state = { 
                        lines: [],
                        currentLine: 0,
                        progress: 0
                    };
                    
                    // Generate Truss Design for 3D Printing
                    const yBase = 250;
                    const yArchTop = 100;
                    const span = 500;
                    const startX = 50;
                    const segments = 10;
                    const segWidth = span / segments;
                    
                    // Bottom chord
                    sim.state.lines.push({x1: startX, y1: yBase, x2: startX + span, y2: yBase});
                    
                    // Arch (Top chord segments) & Web members
                    const getH = (x) => 0.0024 * Math.pow(x - 300, 2) + yArchTop;
                    
                    for(let i=0; i<segments; i++) {
                        const x1 = startX + i * segWidth;
                        const x2 = startX + (i+1) * segWidth;
                        
                        // Top chord segment
                        sim.state.lines.push({x1: x1, y1: getH(x1), x2: x2, y2: getH(x2)});
                        // Vertical
                        sim.state.lines.push({x1: x2, y1: yBase, x2: x2, y2: getH(x2)});
                        // Diagonal
                        if (i < segments/2) sim.state.lines.push({x1: x1, y1: yBase, x2: x2, y2: getH(x2)});
                        else sim.state.lines.push({x1: x1, y1: getH(x1), x2: x2, y2: yBase});
                    }
                    // First vertical
                    sim.state.lines.push({x1: startX, y1: yBase, x2: startX, y2: getH(startX)});

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        // Background
                        ctx.fillStyle = '#111'; ctx.fillRect(0,0,600,350);
                        ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
                        for(let i=0; i<600; i+=20) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,350); ctx.stroke(); }
                        for(let i=0; i<350; i+=20) { ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(600,i); ctx.stroke(); }

                        // Draw completed lines
                        ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 3;
                        ctx.shadowBlur = 5; ctx.shadowColor = '#00ffff'; ctx.lineCap = 'round';

                        for(let i=0; i<sim.state.currentLine; i++) {
                            const l = sim.state.lines[i];
                            ctx.beginPath(); ctx.moveTo(l.x1, l.y1); ctx.lineTo(l.x2, l.y2); ctx.stroke();
                        }
                        
                        // Draw current line
                        if (sim.state.currentLine < sim.state.lines.length) {
                            const l = sim.state.lines[sim.state.currentLine];
                            const dx = l.x2 - l.x1; const dy = l.y2 - l.y1;
                            const len = Math.sqrt(dx*dx + dy*dy);
                            
                            sim.state.progress += 5;
                            if (sim.state.progress >= len) {
                                sim.state.progress = 0;
                                sim.state.currentLine++;
                            } else {
                                const t = sim.state.progress / len;
                                const cx = l.x1 + dx * t; const cy = l.y1 + dy * t;
                                ctx.beginPath(); ctx.moveTo(l.x1, l.y1); ctx.lineTo(cx, cy); ctx.stroke();
                                
                                // Nozzle
                                ctx.shadowBlur = 0;
                                ctx.fillStyle = '#ff00ff'; ctx.fillRect(cx - 3, cy - 15, 6, 15);
                                ctx.fillStyle = '#fff'; ctx.fillRect(cx - 10, cy - 30, 20, 15);
                                ctx.fillStyle = '#ffff00'; ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI*2); ctx.fill();
                            }
                        } else {
                            if (sim.state.progress++ > 100) { sim.state.currentLine = 0; sim.state.progress = 0; }
                            ctx.shadowBlur = 0; ctx.fillStyle = '#fff'; ctx.font = "20px sans-serif"; ctx.textAlign = "center";
                            ctx.fillText("Automated Construction Complete", 300, 50);
                        }

                        document.getElementById('sim-feedback').textContent = "Autonomous 3D Printing in progress...";
                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 24. CERTIFICATE
            certificate: {
                init: function(sim) {
                    sim.state = { stamped: false };
                    sim.canvas.onclick = () => sim.state.stamped = true;

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.fillStyle = '#fff'; ctx.fillRect(0,0,600,350);
                        ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 10; ctx.strokeRect(20, 20, 560, 310);
                        
                        ctx.fillStyle = '#2c3e50'; ctx.font = '30px serif'; ctx.textAlign = 'center';
                        ctx.fillText("Certificate of Mastery", 300, 100);
                        ctx.font = '20px sans-serif';
                        ctx.fillText("Awarded to the Apprentice", 300, 150);
                        ctx.fillText("For excellence in Bridge Engineering", 300, 180);

                        if(sim.state.stamped) {
                            ctx.save();
                            ctx.translate(450, 250);
                            ctx.rotate(-0.2);
                            ctx.beginPath(); ctx.arc(0,0,50,0,Math.PI*2);
                            ctx.strokeStyle = '#c0392b'; ctx.lineWidth = 5; ctx.stroke();
                            ctx.fillStyle = 'rgba(192, 57, 43, 0.1)'; ctx.fill();
                            ctx.fillStyle = '#c0392b'; ctx.font = 'bold 20px sans-serif';
                            ctx.fillText("APPROVED", 0, 5);
                            ctx.restore();
                            document.getElementById('sim-feedback').textContent = "Certified!";
                        } else {
                            document.getElementById('sim-feedback').textContent = "Click to Stamp.";
                        }

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // Fallback for static pages
            beam_static: { 
                init: function(sim) { 
                    const ctx = sim.ctx;
                    ctx.clearRect(0,0,600,350);
                    
                    // Sky/Background
                    ctx.fillStyle = '#f0f8ff'; ctx.fillRect(0,0,600,350);

                    // Ground
                    ctx.fillStyle = '#27ae60'; ctx.fillRect(0, 300, 600, 50);
                    
                    // Water
                    ctx.fillStyle = '#3498db'; ctx.fillRect(150, 310, 300, 40);

                    // Piers
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillRect(120, 200, 30, 110);
                    ctx.fillRect(450, 200, 30, 110);

                    // Beam
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(120, 200, 360, 20);

                    // Labels
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = 'bold 14px sans-serif';
                    ctx.textAlign = 'center';
                    
                    // Force Arrows
                    ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 2;

                    // Load (Gravity/Traffic)
                    ctx.fillText("Load (Weight)", 300, 150);
                    ctx.beginPath(); ctx.moveTo(300, 160); ctx.lineTo(300, 195); 
                    ctx.lineTo(295, 190); ctx.moveTo(300, 195); ctx.lineTo(305, 190); ctx.stroke();

                    // Reactions (Piers pushing up)
                    ctx.fillText("Reaction", 135, 330);
                    ctx.beginPath(); ctx.moveTo(135, 315); ctx.lineTo(135, 225); 
                    ctx.lineTo(130, 230); ctx.moveTo(135, 225); ctx.lineTo(140, 230); ctx.stroke();

                    ctx.fillText("Reaction", 465, 330);
                    ctx.beginPath(); ctx.moveTo(465, 315); ctx.lineTo(465, 225); 
                    ctx.lineTo(460, 230); ctx.moveTo(465, 225); ctx.lineTo(470, 230); ctx.stroke();
                    
                    // Span Label
                    ctx.beginPath(); ctx.moveTo(150, 240); ctx.lineTo(450, 240); ctx.stroke();
                    ctx.fillText("Span (Distance)", 300, 260);
                } 
            },
            truss_static: { 
                init: function(sim) { 
                    const ctx = sim.ctx;
                    ctx.clearRect(0,0,600,350);
                    
                    // Sky/Background
                    ctx.fillStyle = '#f0f8ff'; ctx.fillRect(0,0,600,350);

                    // Ground
                    ctx.fillStyle = '#27ae60'; ctx.fillRect(0, 300, 600, 50);
                    
                    // Water
                    ctx.fillStyle = '#3498db'; ctx.fillRect(150, 310, 300, 40);

                    // Piers
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillRect(100, 200, 30, 110);
                    ctx.fillRect(470, 200, 30, 110);

                    // Truss Structure
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.strokeStyle = '#2c3e50';

                    // Bottom Chord
                    ctx.beginPath(); ctx.moveTo(100, 200); ctx.lineTo(500, 200); ctx.stroke();
                    
                    // Top Chord
                    ctx.beginPath(); ctx.moveTo(150, 120); ctx.lineTo(450, 120); ctx.stroke();

                    // Diagonals & Verticals
                    ctx.beginPath();
                    // Left slope
                    ctx.moveTo(100, 200); ctx.lineTo(150, 120);
                    // Right slope
                    ctx.moveTo(500, 200); ctx.lineTo(450, 120);
                    
                    // Zig-zags
                    ctx.moveTo(150, 120); ctx.lineTo(200, 200);
                    ctx.lineTo(250, 120); ctx.lineTo(300, 200);
                    ctx.lineTo(350, 120); ctx.lineTo(400, 200);
                    ctx.lineTo(450, 120);
                    ctx.stroke();

                    // Joints
                    ctx.fillStyle = '#34495e';
                    const joints = [
                        {x:100, y:200}, {x:500, y:200},
                        {x:150, y:120}, {x:450, y:120},
                        {x:200, y:200}, {x:250, y:120},
                        {x:300, y:200}, {x:350, y:120},
                        {x:400, y:200}
                    ];
                    joints.forEach(j => {
                        ctx.beginPath(); ctx.arc(j.x, j.y, 5, 0, Math.PI*2); ctx.fill();
                    });

                    // Labels
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = 'bold 14px sans-serif';
                    ctx.textAlign = 'center';
                    
                    ctx.fillText("Top Chord (Compression)", 300, 100);
                    ctx.fillText("Bottom Chord (Tension)", 300, 230);
                    
                    // Force arrows on members (simplified visual)
                    ctx.strokeStyle = '#e74c3c'; // Compression
                    ctx.lineWidth = 2;
                    // Arrows pointing in on top chord
                    ctx.beginPath(); ctx.moveTo(280, 110); ctx.lineTo(290, 110); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(320, 110); ctx.lineTo(310, 110); ctx.stroke();

                    ctx.strokeStyle = '#3498db'; // Tension
                    // Arrows pointing out on bottom chord
                    ctx.beginPath(); ctx.moveTo(280, 210); ctx.lineTo(270, 210); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(320, 210); ctx.lineTo(330, 210); ctx.stroke();
                } 
            },
            arch_static: {
                init: function(sim) {
                    const ctx = sim.ctx;
                    ctx.clearRect(0,0,600,350);
                    
                    // Sky/Background
                    ctx.fillStyle = '#f0f8ff'; ctx.fillRect(0,0,600,350);

                    // Ground
                    ctx.fillStyle = '#27ae60'; ctx.fillRect(0, 300, 600, 50);
                    
                    // Water
                    ctx.fillStyle = '#3498db'; ctx.fillRect(150, 310, 300, 40);

                    // Abutments
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillRect(50, 200, 100, 100);
                    ctx.fillRect(450, 200, 100, 100);

                    // Arch
                    ctx.strokeStyle = '#95a5a6'; ctx.lineWidth = 20;
                    ctx.beginPath(); ctx.arc(300, 300, 150, Math.PI, 0); ctx.stroke();

                    // Deck
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillRect(50, 140, 500, 10);

                    // Spandrels (fill)
                    ctx.fillStyle = '#bdc3c7';
                    ctx.beginPath();
                    ctx.moveTo(150, 150);
                    ctx.lineTo(450, 150);
                    ctx.lineTo(450, 300);
                    ctx.arc(300, 300, 150, 0, Math.PI, true);
                    ctx.lineTo(150, 300);
                    ctx.closePath();
                    ctx.fill();

                    // Labels & Forces
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = 'bold 14px sans-serif';
                    ctx.textAlign = 'center';
                    
                    ctx.fillText("Keystone", 300, 130);
                    
                    // Compression Arrows
                    ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 4;
                    
                    // Left side (curved)
                    const startL = 260 * Math.PI / 180;
                    const endL = 200 * Math.PI / 180;
                    ctx.beginPath(); ctx.arc(300, 300, 150, startL, endL, true); ctx.stroke();
                    // Arrowhead Left
                    const xL = 300 + 150 * Math.cos(endL); const yL = 300 + 150 * Math.sin(endL);
                    const tanL = endL - Math.PI / 2;
                    ctx.beginPath(); ctx.moveTo(xL, yL); ctx.lineTo(xL + 15 * Math.cos(tanL + 2.6), yL + 15 * Math.sin(tanL + 2.6)); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(xL, yL); ctx.lineTo(xL + 15 * Math.cos(tanL - 2.6), yL + 15 * Math.sin(tanL - 2.6)); ctx.stroke();
                    
                    // Right side (curved)
                    const startR = 280 * Math.PI / 180;
                    const endR = 340 * Math.PI / 180;
                    ctx.beginPath(); ctx.arc(300, 300, 150, startR, endR, false); ctx.stroke();
                    // Arrowhead Right
                    const xR = 300 + 150 * Math.cos(endR); const yR = 300 + 150 * Math.sin(endR);
                    const tanR = endR + Math.PI / 2;
                    ctx.beginPath(); ctx.moveTo(xR, yR); ctx.lineTo(xR + 15 * Math.cos(tanR + 2.6), yR + 15 * Math.sin(tanR + 2.6)); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(xR, yR); ctx.lineTo(xR + 15 * Math.cos(tanR - 2.6), yR + 15 * Math.sin(tanR - 2.6)); ctx.stroke();

                    ctx.fillStyle = '#e74c3c';
                    ctx.fillText("Compression", 180, 200);
                    ctx.fillText("Compression", 420, 200);

                    // Thrust
                    ctx.fillText("Thrust", 100, 280);
                    ctx.beginPath(); ctx.moveTo(150, 300); ctx.lineTo(100, 300); ctx.lineTo(110, 290); ctx.moveTo(100, 300); ctx.lineTo(110, 310); ctx.stroke();
                    
                    ctx.fillText("Thrust", 500, 280);
                    ctx.beginPath(); ctx.moveTo(450, 300); ctx.lineTo(500, 300); ctx.lineTo(490, 290); ctx.moveTo(500, 300); ctx.lineTo(490, 310); ctx.stroke();
                }
            },
            suspension_static: {
                init: function(sim) {
                    const ctx = sim.ctx;
                    ctx.clearRect(0,0,600,350);
                    
                    // Sky/Background
                    ctx.fillStyle = '#f0f8ff'; ctx.fillRect(0,0,600,350);

                    // Water
                    ctx.fillStyle = '#3498db'; ctx.fillRect(0, 300, 600, 50);

                    // Anchorages
                    ctx.fillStyle = '#95a5a6';
                    ctx.fillRect(0, 220, 80, 80);
                    ctx.fillRect(520, 220, 80, 80);

                    // Towers
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillRect(120, 50, 20, 250);
                    ctx.fillRect(460, 50, 20, 250);

                    // Deck
                    ctx.fillStyle = '#bdc3c7';
                    ctx.fillRect(0, 250, 600, 10);

                    // Main Cable
                    const sag = 80;
                    ctx.strokeStyle = '#e67e22'; ctx.lineWidth = 3;
                    ctx.beginPath();
                    // Left anchor to tower
                    ctx.moveTo(40, 220); ctx.lineTo(120, 50);
                    // Main span
                    ctx.quadraticCurveTo(300, 50 + sag * 2, 480, 50);
                    // Tower to right anchor
                    ctx.lineTo(560, 220);
                    ctx.stroke();

                    // Suspenders
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = '#2c3e50';
                    for(let x=140; x<460; x+=20) {
                        const t = (x - 120) / 360;
                        const y = (1-t)*(1-t)*50 + 2*(1-t)*t*(50+sag*2) + t*t*50;
                        ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, 250); ctx.stroke();
                    }

                    // Labels
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = 'bold 14px sans-serif';
                    ctx.textAlign = 'center';
                    
                    ctx.fillText("Main Cable (Tension)", 300, 80);
                    ctx.fillText("Tower (Compression)", 130, 40);
                    ctx.fillText("Tower (Compression)", 470, 40);
                    ctx.fillText("Anchorage", 40, 210);
                    ctx.fillText("Anchorage", 560, 210);
                }
            }
        };

        // Initialize
        window.onload = function() {
            Book.init();
        };
    </script>
</body>
</html>