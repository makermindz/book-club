<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Quest for the Lost Spark - A STEM Adventure</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'green-primary': '#27ae60',
                        'green-secondary': '#2ecc71',
                        'green-light': '#f4fff4',
                        'brand-dark': '#2c3e50',
                        'paper': '#fdfbf7',
                    },
                    fontFamily: {
                        sans: ['Segoe UI', 'Tahoma', 'Geneva', 'Verdana', 'sans-serif'],
                        serif: ['Georgia', 'Cambria', 'Times New Roman', 'Times', 'serif'],
                    },
                    boxShadow: {
                        'book': '0 20px 30px -10px rgba(0, 0, 0, 0.3), 0 0 10px rgba(0,0,0,0.1)',
                        'page': 'inset 0 0 30px rgba(0,0,0,0.05)',
                    }
                }
            }
        }
    </script>
    <style>
        body {
            background-color: #2c3e50;
            background-image: radial-gradient(#34495e 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        .book-container {
            perspective: 1500px;
        }

        .book-page {
            transition: transform 0.8s cubic-bezier(0.645, 0.045, 0.355, 1);
            transform-style: preserve-3d;
            transform-origin: left center;
        }

        .page-content {
            backface-visibility: hidden;
        }

        /* Simulation Canvas Styles */
        canvas {
            border-radius: 0.5rem;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
            background-color: #fff;
            cursor: pointer;
        }

        .sim-control-panel {
            background: #f4fff4;
            border: 1px solid #2ecc71;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
        }

        /* Custom Range Slider */
        input[type=range] {
            height: 6px;
            background: #e2e8f0;
            border-radius: 5px;
            outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #27ae60;
            cursor: pointer;
        }
    </style>
</head>
<body class="h-screen flex items-center justify-center overflow-hidden">

    <div class="book-container w-full max-w-5xl h-[90vh] relative flex items-center justify-center">
        
        <!-- Book Spine/Back -->
        <div class="absolute inset-0 bg-brand-dark rounded-r-2xl shadow-2xl transform translate-x-2 translate-y-2"></div>

        <!-- Active Page Container -->
        <div id="book-page" class="book-page relative w-full h-full bg-paper rounded-r-xl shadow-book flex flex-col md:flex-row overflow-hidden border-l-8 border-gray-200">
            
            <!-- Left Side: Story & Text -->
            <div class="w-full md:w-1/3 p-8 md:p-12 flex flex-col justify-center border-r border-gray-100 bg-white relative">
                <div class="absolute top-0 left-0 w-full h-2 bg-gradient-to-r from-green-primary to-green-secondary"></div>
                
                <div class="mb-4 text-green-primary font-bold uppercase tracking-widest text-xs">
                    
                    Page <span id="page-num">1</span> of <span id="total-pages">13</span>
                </div>
                
                <h2 id="story-title" class="text-3xl font-serif font-bold text-brand-dark mb-6 leading-tight"></h2>
                
                <div id="story-text" class="prose text-gray-600 leading-relaxed mb-8">
                    <!-- Story content injected here -->
                </div>

                <div class="mt-auto flex gap-4">
                    <button onclick="Book.prevPage()" id="btn-prev" class="flex-1 px-4 py-3 rounded-lg border-2 border-gray-200 text-gray-500 font-bold hover:border-brand-dark hover:text-brand-dark transition disabled:opacity-30 disabled:cursor-not-allowed">
                        ← Previous
                    </button>
                    <button onclick="Book.nextPage()" id="btn-next" class="flex-1 px-4 py-3 rounded-lg bg-green-primary text-white font-bold hover:bg-green-secondary shadow-lg transition transform hover:-translate-y-1 disabled:opacity-50 disabled:cursor-not-allowed">
                        Next Page →
                    </button>
                </div>
            </div>

            <!-- Right Side: Interactive Simulation -->
            <div class="w-full md:w-2/3 bg-green-light relative p-6 flex flex-col items-center justify-center">
                <div class="absolute top-4 right-4 text-gray-500 text-s font-sans z-20">
                    &copy; Maker Mindz
                </div>
                <div class="absolute top-6 right-6 text-brand-dark opacity-10 text-9xl font-serif font-bold select-none">
                    ⚡
                </div>
                
                <div id="sim-container" class="w-full max-w-2xl z-10">
                    <div class="bg-white p-2 rounded-xl shadow-lg border border-gray-200">
                        <canvas id="sim-canvas" width="600" height="350" class="w-full h-auto bg-gray-50 rounded-lg"></canvas>
                    </div>
                    
                    <div id="sim-controls" class="sim-control-panel shadow-sm">
                        <!-- Controls injected here -->
                    </div>
                    
                    <div id="sim-feedback" class="mt-3 text-center font-bold text-brand-dark min-h-[1.5rem]"></div>
                </div>
            </div>

        </div>
    </div>

    <script>
        // --- BOOK CONTENT & LOGIC ---
        
        const Pages = [
            {
                title: "The Quest for the Lost Spark",
                text: "Welcome to a world powered by Science, Technology, Engineering, and Math. Join Alex on her journey to restore energy to Technopolis. This interactive book will test your knowledge and skills!",
                simType: "cover",
                instruction: "Enjoy the view and click 'Next Page' to begin."
            },
            {
                title: "The Quest Begins",
                text: "Alex, a young inventor in Technopolis, found the city dark and silent. The Great Spark had faded. In her grandfather's workshop, she discovered an ancient holographic map. It pulsed with faint energy, showing the path to restore the power. But the map was locked.",
                simType: "map",
                instruction: "Hover over the nodes to unlock the path."
            },
            {
                title: "The Bridge of Logic",
                text: "The first obstacle was a drawbridge controlled by an old computer. The system was offline, and the logic gates were scrambled. To lower the bridge, Alex needed to send a 'TRUE' signal to the motor.",
                simType: "logic",
                instruction: "Toggle the switches to get the output light to turn GREEN."
            },
            {
                title: "The River of Currents",
                text: "Crossing the rushing river required a boat, but the current was too strong. Alex remembered Bernoulli's principle: changing the channel width changes the fluid speed. She had to navigate the flow carefully.",
                simType: "fluid",
                instruction: "Adjust the river width slider to control the water speed and guide the boat."
            },
            {
                title: "The Slope of Friction",
                text: "The path led up a steep, icy mountain. Alex's boots kept slipping. She needed to increase the friction to climb. She found some gravel and sand nearby to spread on the path.",
                simType: "friction",
                instruction: "Increase the Surface Roughness (µ) until Alex can climb the slope without sliding back."
            },
            {
                title: "The Cave of Echoes",
                text: "A massive stone door blocked the cave entrance. It was sound-activated, responding only to a specific resonant frequency. Alex tuned her sonic emitter to match the door's hum.",
                simType: "sound",
                instruction: "Adjust the Frequency slider until the wave matches the target pattern."
            },
            {
                title: "The Solar Lock",
                text: "A heavy door blocked the path, secured by a solar-thermal lock. It required intense, concentrated heat to open. Alex found a large convex lens in her pack. She needed to focus the ambient light onto the lock's sensor.",
                simType: "optics",
                instruction: "Drag the lens left or right to focus the light rays onto the red sensor."
            },
            {
                title: "The Acidic Swamp",
                text: "The swamp waters were dangerously acidic, blocking the way. Alex had a supply of neutralizing base. She needed to add just enough to make the water safe (pH 7) to cross.",
                simType: "chemistry",
                instruction: "Add drops of Base to raise the pH to exactly 7 (Neutral)."
            },
            {
                title: "The Magnetic Junkyard",
                text: "The path was buried under heavy scrap metal. Alex built a temporary electromagnet using a battery and a coil of wire to lift the debris.",
                simType: "magnetism",
                instruction: "Hold the 'Activate' button to energize the magnet and move the scrap metal."
            },
            {
                title: "The Circuit Gate",
                text: "The gate to the Power Core was locked. The wiring was old and disconnected. Alex had to repair the circuit to let the electrons flow and unlock the door.",
                simType: "circuit",
                instruction: "Click the wire segments to rotate them and complete the path from Battery to Lock."
            },
            {
                title: "The Sleeping Generator",
                text: "She reached the heart of Technopolis. The massive generator stood still. It needed a jumpstart. Using Faraday's Law, Alex spun the starter coil to induce the first spark.",
                simType: "generator",
                instruction: "Spin the wheel quickly with your mouse/finger to generate voltage!"
            },
            {
                title: "The Grid Awakens",
                text: "The generator roared to life! Now, the energy had to be distributed. Alex managed the grid, connecting power lines to the city districts without overloading the system.",
                simType: "grid",
                instruction: "Click nodes to connect the power plant (Green) to the houses (Red)."
            },
            {
                title: "Technopolis Restored",
                text: "Lights flickered on across the city. The hum of machinery returned. Alex had done it! Through logic, physics, and chemistry, she had restored the spark to Technopolis.",
                simType: "fireworks",
                instruction: "Click the sky to celebrate!"
            },
            {
                title: "Summary: Logic Gates",
                text: "Logic gates are the building blocks of digital electronics. An AND gate, like the one used in the bridge, requires all inputs to be true (ON) for the output to be true. This is fundamental to how computers process information.",
                simType: "logic",
                instruction: "Experiment with the switches to see the truth table in action."
            },
            {
                title: "Summary: Fluid Dynamics",
                text: "Bernoulli's principle states that for a fluid, an increase in speed occurs simultaneously with a decrease in pressure. In the river, narrowing the channel forced the water to speed up to maintain the flow rate (Continuity Equation).",
                simType: "fluid",
                instruction: "Observe how the water speed changes as you adjust the river width."
            },
            {
                title: "Summary: Friction",
                text: "Friction is a force that opposes motion between two surfaces in contact. It depends on the texture of the surfaces (coefficient of friction, µ) and the force pressing them together. Higher µ means more grip!",
                simType: "friction",
                instruction: "Test different roughness levels to see how they affect movement."
            },
            {
                title: "Summary: Sound & Resonance",
                text: "Sound travels as a wave. Every object has a natural frequency at which it vibrates. Resonance occurs when a sound wave matches this natural frequency, causing the object to vibrate with greater amplitude.",
                simType: "sound",
                instruction: "Find the resonant frequency again."
            },
            {
                title: "Summary: Optics & Refraction",
                text: "When light passes through a lens, it bends (refracts). A convex lens converges parallel light rays to a single focal point. This principle is used in eyes, cameras, and magnifying glasses.",
                simType: "optics",
                instruction: "Focus the light again."
            },
            {
                title: "Summary: Acids & Bases",
                text: "The pH scale measures how acidic or basic a substance is. Acids have a pH less than 7, while bases have a pH greater than 7. Mixing them can neutralize the solution, bringing the pH closer to 7 (like water).",
                simType: "chemistry",
                instruction: "Neutralize the solution again."
            },
            {
                title: "Summary: Electromagnetism",
                text: "An electric current flowing through a wire creates a magnetic field. By coiling the wire, we can concentrate this field to create a strong magnet that can be turned on and off.",
                simType: "magnetism",
                instruction: "Activate the electromagnet to see the magnetic field lines."
            },
            {
                title: "Summary: Electric Circuits",
                text: "An electric circuit is a closed path that allows electrons to flow, powering devices. If the path is broken (open circuit), the current stops. Switches and wires control this flow.",
                simType: "circuit",
                instruction: "Close the circuit to let the power flow."
            },
            {
                title: "Summary: Electromagnetic Induction",
                text: "Faraday's Law of Induction explains how a changing magnetic field can create an electric current. Spinning a coil inside a magnetic field (or moving a magnet near a coil) generates electricity.",
                simType: "generator",
                instruction: "Spin the generator to induce a current."
            },
            {
                title: "Summary: Power Distribution",
                text: "A power grid is a network for delivering electricity from producers to consumers. It consists of generating stations, transmission lines, and distribution systems that must be balanced to prevent blackouts.",
                simType: "grid",
                instruction: "Connect the grid nodes to distribute power."
            },
            {
                title: "Your Adventure Continues!",
                text: "You've helped Alex restore Technopolis, but your STEM journey is just beginning! The world is full of puzzles waiting to be solved. Keep asking questions, keep experimenting, and keep building. What will you create next?",
                simType: "sandbox",
                instruction: "Click to add blocks and build your own creation in this physics sandbox!"
            }
        ];

        const Book = {
            currentPage: 0,
            
            init: function() {
                this.renderPage();
            },

            nextPage: function() {
                if (this.currentPage < Pages.length - 1) {
                    this.currentPage++;
                    this.renderPage();
                } else {
                    this.currentPage = 0;
                    this.renderPage();
                }
            },

            prevPage: function() {
                if (this.currentPage > 0) {
                    this.currentPage--;
                    this.renderPage();
                }
            },

            renderPage: function() {
                const page = Pages[this.currentPage];
                
                // Update Text
                document.getElementById('page-num').textContent = this.currentPage + 1;
                document.getElementById('total-pages').textContent = Pages.length;
                document.getElementById('story-title').textContent = page.title;
                document.getElementById('story-text').innerHTML = `<p>${page.text}</p><p class="mt-4 text-sm font-bold text-green-primary italic">Task: ${page.instruction}</p>`;
                
                // Update Buttons
                document.getElementById('btn-prev').disabled = this.currentPage === 0;
                document.getElementById('btn-next').disabled = false;
                if (this.currentPage === Pages.length - 1) {
                    document.getElementById('btn-next').textContent = "Restart";
                } else {
                    document.getElementById('btn-next').textContent = "Next Page →";
                }

                // Load Simulation
                Simulations.load(page.simType);
            }
        };

        const Simulations = {
            canvas: null,
            ctx: null,
            animId: null,
            activeType: null,
            state: {},

            load: function(type) {
                if (this.animId) cancelAnimationFrame(this.animId);
                this.activeType = type;
                this.canvas = document.getElementById('sim-canvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Reset controls
                document.getElementById('sim-controls').innerHTML = '';
                document.getElementById('sim-feedback').textContent = '';

                // Initialize specific simulation
                if (this[type]) this[type].init(this);
            },

            // 0. COVER
            cover: {
                init: function(sim) {
                    sim.state = { t: 0, particles: [] };
                    for(let i=0; i<50; i++) {
                        sim.state.particles.push({
                            x: Math.random() * 600,
                            y: Math.random() * 350,
                            r: Math.random() * 15 + 5,
                            color: `hsl(${Math.random()*360}, 80%, 60%)`,
                            vx: (Math.random()-0.5)*1,
                            vy: (Math.random()-0.5)*1
                        });
                    }

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        ctx.fillRect(0, 0, 600, 350);
                        
                        sim.state.particles.forEach(p => {
                            p.x += p.vx; p.y += p.vy;
                            if(p.x < 0 || p.x > 600) p.vx *= -1;
                            if(p.y < 0 || p.y > 350) p.vy *= -1;
                            ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
                            ctx.fillStyle = p.color; ctx.fill();
                        });
                        
                        ctx.shadowBlur = 10; ctx.shadowColor = "white";
                        ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 48px serif'; ctx.textAlign = 'center';
                        ctx.fillText("STEM Adventure", 300, 160);
                        ctx.font = 'italic 24px sans-serif'; ctx.fillStyle = '#27ae60';
                        ctx.fillText("The Quest for the Lost Spark", 300, 200);
                        ctx.shadowBlur = 0;
                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 1. MAP
            map: {
                init: function(sim) {
                    sim.state = { nodes: [], hover: -1 };
                    for(let i=0; i<5; i++) {
                        sim.state.nodes.push({x: 100 + i*100, y: 175 + Math.sin(i)*50, active: false});
                    }
                    
                    sim.canvas.onmousemove = (e) => {
                        const rect = sim.canvas.getBoundingClientRect();
                        const mx = e.clientX - rect.left;
                        const my = e.clientY - rect.top;
                        sim.state.hover = -1;
                        sim.state.nodes.forEach((n, i) => {
                            const d = Math.sqrt((mx-n.x)**2 + (my-n.y)**2);
                            if (d < 20) {
                                n.active = true;
                                sim.state.hover = i;
                            }
                        });
                    };

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0, 0, 600, 350);
                        
                        // Draw Path
                        ctx.strokeStyle = '#2c3e50';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([10, 10]);
                        ctx.beginPath();
                        sim.state.nodes.forEach((n, i) => {
                            if (i===0) ctx.moveTo(n.x, n.y);
                            else ctx.lineTo(n.x, n.y);
                        });
                        ctx.stroke();
                        ctx.setLineDash([]);

                        // Draw Nodes
                        let allActive = true;
                        sim.state.nodes.forEach(n => {
                            ctx.fillStyle = n.active ? '#2ecc71' : '#bdc3c7';
                            ctx.beginPath(); ctx.arc(n.x, n.y, 10, 0, Math.PI*2); ctx.fill();
                            if (n.active) {
                                ctx.shadowBlur = 15; ctx.shadowColor = '#2ecc71';
                                ctx.strokeStyle = '#fff'; ctx.stroke(); ctx.shadowBlur = 0;
                            }
                            if (!n.active) allActive = false;
                        });

                        if (allActive) document.getElementById('sim-feedback').textContent = "Map Unlocked! Proceed to the next page.";
                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 2. LOGIC
            logic: {
                init: function(sim) {
                    sim.state = { s1: false, s2: false };
                    const controls = document.getElementById('sim-controls');
                    controls.innerHTML = `
                        <div class="flex justify-center gap-8">
                            <label class="flex items-center gap-2 font-bold text-brand-dark cursor-pointer"><input type="checkbox" id="sw1" class="w-6 h-6 accent-green-primary"> Switch A</label>
                            <label class="flex items-center gap-2 font-bold text-brand-dark cursor-pointer"><input type="checkbox" id="sw2" class="w-6 h-6 accent-green-primary"> Switch B</label>
                        </div>
                        <div class="text-center mt-2 text-sm text-gray-500">Logic: (A OR B) AND (NOT A)</div>
                    `;
                    
                    const update = () => {
                        sim.state.s1 = document.getElementById('sw1').checked;
                        sim.state.s2 = document.getElementById('sw2').checked;
                    };
                    document.getElementById('sw1').onchange = update;
                    document.getElementById('sw2').onchange = update;

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        const a = sim.state.s1;
                        const b = sim.state.s2;
                        // Logic: (A || B) && !A  => This simplifies to (!A && B)
                        // Wait, let's make it simpler for kids: A AND B
                        // Or the riddle: "Both must be true"
                        const result = a && b;

                        // Draw Gate Visual
                        ctx.fillStyle = '#ecf0f1'; ctx.fillRect(100, 100, 400, 150);
                        ctx.strokeStyle = '#2c3e50'; ctx.strokeRect(100, 100, 400, 150);

                        // Inputs
                        ctx.fillStyle = a ? '#2ecc71' : '#e74c3c'; ctx.beginPath(); ctx.arc(150, 150, 10, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='#000'; ctx.fillText("A", 145, 140);
                        ctx.fillStyle = b ? '#2ecc71' : '#e74c3c'; ctx.beginPath(); ctx.arc(150, 200, 10, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='#000'; ctx.fillText("B", 145, 190);

                        // Gate Box
                        ctx.fillStyle = '#34495e'; ctx.fillRect(250, 140, 60, 70); ctx.fillStyle='#fff'; ctx.fillText("AND", 280, 180);

                        // Wires
                        ctx.strokeStyle = '#7f8c8d'; ctx.lineWidth = 4;
                        ctx.beginPath(); ctx.moveTo(160, 150); ctx.lineTo(250, 150); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(160, 200); ctx.lineTo(250, 200); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(310, 175); ctx.lineTo(400, 175); ctx.stroke();

                        // Output Light
                        ctx.fillStyle = result ? '#2ecc71' : '#95a5a6';
                        ctx.beginPath(); ctx.arc(420, 175, 20, 0, Math.PI*2); ctx.fill();
                        if(result) {
                            ctx.shadowBlur = 20; ctx.shadowColor = '#2ecc71'; ctx.stroke(); ctx.shadowBlur = 0;
                            document.getElementById('sim-feedback').textContent = "Bridge Lowered!";
                        } else {
                            document.getElementById('sim-feedback').textContent = "Bridge Locked.";
                        }

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 3. FLUIDS
            fluid: {
                init: function(sim) {
                    sim.state = { width: 50, boatX: 0 };
                    document.getElementById('sim-controls').innerHTML = `
                        <div class="flex items-center gap-4"><span class="font-bold">River Width:</span><input type="range" min="20" max="150" value="50" class="flex-1" oninput="Simulations.state.width=parseInt(this.value)"></div>
                    `;
                    
                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        const w = sim.state.width;
                        const speed = 200 / w; // Narrower = Faster
                        
                        // River Banks
                        ctx.fillStyle = '#27ae60';
                        ctx.fillRect(0, 0, 600, 175 - w/2);
                        ctx.fillRect(0, 175 + w/2, 600, 175 - w/2);
                        
                        // Water
                        ctx.fillStyle = '#3498db';
                        ctx.fillRect(0, 175 - w/2, 600, w);

                        // Boat
                        sim.state.boatX += speed * 0.5;
                        if(sim.state.boatX > 600) sim.state.boatX = -50;
                        
                        ctx.fillStyle = '#e67e22';
                        ctx.beginPath(); ctx.ellipse(sim.state.boatX, 175, 20, 10, 0, 0, Math.PI*2); ctx.fill();
                        
                        // Particles
                        ctx.fillStyle = 'rgba(255,255,255,0.5)';
                        for(let i=0; i<10; i++) {
                            const px = (Date.now()/5 * speed + i*60) % 600;
                            ctx.beginPath(); ctx.arc(px, 175, 2, 0, Math.PI*2); ctx.fill();
                        }

                        const targetWidth = 80;
                        const targetSpeed = 200 / targetWidth;
                        if (Math.abs(w - targetWidth) <= 5) {
                            document.getElementById('sim-feedback').textContent = `Current Speed: ${speed.toFixed(1)} m/s. Perfect! Optimum flow.`;
                            document.getElementById('sim-feedback').className = "mt-3 text-center font-bold text-green-primary";
                        } else {
                            document.getElementById('sim-feedback').textContent = `Current Speed: ${speed.toFixed(1)} m/s. Optimum: ${targetSpeed.toFixed(1)} m/s (Width ~${targetWidth})`;
                            document.getElementById('sim-feedback').className = "mt-3 text-center font-bold text-brand-dark";
                        }
                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 4. FRICTION
            friction: {
                init: function(sim) {
                    sim.state = { mu: 0.1, y: 300, x: 50 };
                    document.getElementById('sim-controls').innerHTML = `
                        <div class="flex items-center gap-4"><span class="font-bold">Surface Roughness (µ):</span><input type="range" min="0" max="1" step="0.1" value="0.1" class="flex-1" oninput="Simulations.state.mu=parseFloat(this.value)"></div>
                    `;

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        // Slope
                        ctx.beginPath(); ctx.moveTo(0, 350); ctx.lineTo(600, 100); ctx.lineTo(600, 350); ctx.fillStyle = '#95a5a6'; ctx.fill();
                        
                        // Texture based on mu
                        if(sim.state.mu > 0.5) {
                            ctx.strokeStyle = '#7f8c8d'; ctx.lineWidth = 2;
                            for(let i=0; i<600; i+=20) { ctx.beginPath(); ctx.moveTo(i, 350 - (i/600)*250); ctx.lineTo(i+10, 350 - (i/600)*250 - 5); ctx.stroke(); }
                        }

                        // Character logic
                        const gravity = 2;
                        const friction = sim.state.mu * 5;
                        const netForce = gravity - friction; // Simplified
                        
                        if (netForce > 0) {
                            sim.state.x -= netForce; // Slide down
                            document.getElementById('sim-feedback').textContent = "Too slippery! Sliding back!";
                            document.getElementById('sim-feedback').className = "mt-3 text-center font-bold text-red-500";
                        } else {
                            sim.state.x += 1; // Climb
                            document.getElementById('sim-feedback').textContent = "Grip is good! Climbing!";
                            document.getElementById('sim-feedback').className = "mt-3 text-center font-bold text-green-primary";
                        }
                        
                        if(sim.state.x < 50) sim.state.x = 50;
                        if(sim.state.x > 550) sim.state.x = 550;

                        const slopeY = 350 - (sim.state.x/600)*250;

                        // Draw Human Character
                        ctx.save();
                        ctx.translate(sim.state.x, slopeY);
                        
                        // Draw Stick Figure
                        ctx.strokeStyle = '#e74c3c';
                        ctx.fillStyle = '#e74c3c';
                        ctx.lineWidth = 3;
                        ctx.lineCap = 'round';
                        
                        // Walking animation
                        const stride = Math.sin(sim.state.x * 0.2) * 8;
                        
                        // Head
                        ctx.beginPath(); ctx.arc(0, -50, 6, 0, Math.PI*2); ctx.fill();
                        // Body
                        ctx.beginPath(); ctx.moveTo(0, -44); ctx.lineTo(0, -20); ctx.stroke();
                        // Legs
                        ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(-5 + stride, 0); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(5 - stride, 0); ctx.stroke();

                        // Boots
                        ctx.fillStyle = '#2c3e50';
                        ctx.fillRect(-5 + stride - 3, -2, 8, 4);
                        ctx.fillRect(5 - stride - 3, -2, 8, 4);


                        // Boots
                        ctx.fillStyle = '#2c3e50';
                        ctx.fillRect(-5 + stride - 3, -2, 8, 4);
                        ctx.fillRect(5 - stride - 3, -2, 8, 4);


                        // Boots
                        ctx.fillStyle = '#2c3e50';
                        ctx.fillRect(-5 + stride - 3, -2, 8, 4);
                        ctx.fillRect(5 - stride - 3, -2, 8, 4);


                        // Boots
                        ctx.fillStyle = '#2c3e50';
                        ctx.fillRect(-5 + stride - 3, -2, 8, 4);
                        ctx.fillRect(5 - stride - 3, -2, 8, 4);


                        // Boots
                        ctx.fillStyle = '#2c3e50';
                        ctx.fillRect(-5 + stride - 3, -2, 8, 4);
                        ctx.fillRect(5 - stride - 3, -2, 8, 4);

                        // Arms
                        ctx.beginPath(); ctx.moveTo(0, -38); ctx.lineTo(-5 - stride, -25); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(0, -38); ctx.lineTo(5 + stride, -25); ctx.stroke();
                        
                        ctx.restore();

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 5. SOUND
            sound: {
                init: function(sim) {
                    sim.state = { freq: 50, target: 150 };
                    document.getElementById('sim-controls').innerHTML = `
                        <div class="flex items-center gap-4"><span class="font-bold">Frequency:</span><input type="range" min="50" max="250" value="50" class="flex-1" oninput="Simulations.state.freq=parseInt(this.value)"></div>
                    `;

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        // Target Wave (Ghost)
                        ctx.strokeStyle = 'rgba(46, 204, 113, 0.3)'; ctx.lineWidth = 5; ctx.beginPath();
                        for(let x=0; x<600; x++) {
                            const y = 175 + Math.sin(x * 0.05) * 50;
                            if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                        }
                        ctx.stroke();

                        // User Wave
                        const wavelength = 2000 / sim.state.freq;
                        ctx.strokeStyle = '#2980b9'; ctx.lineWidth = 3; ctx.beginPath();
                        for(let x=0; x<600; x++) {
                            const y = 175 + Math.sin(x * (Math.PI*2/wavelength)) * 50;
                            if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                        }
                        ctx.stroke();

                        // Check match
                        // Target freq ~ 150 -> wavelength ~ 13.3. 
                        // My math above: sin(x * 0.05). 0.05 = 2PI / lambda. lambda = 125.
                        // 2000 / freq = 125 => freq = 16. 
                        // Let's just check range.
                        if (sim.state.freq > 120 && sim.state.freq < 135) {
                            document.getElementById('sim-feedback').textContent = "Resonance Achieved! Door Opening.";
                            document.getElementById('sim-feedback').className = "mt-3 text-center font-bold text-green-primary";
                        } else {
                            document.getElementById('sim-feedback').textContent = "Frequency Mismatch.";
                            document.getElementById('sim-feedback').className = "mt-3 text-center font-bold text-brand-dark";
                        }

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 6. OPTICS (LENS)
            optics: {
                init: function(sim) {
                    sim.state = { lensX: 100, dragging: false };
                    const targetX = 500;
                    const focalLength = 200;

                    const startDrag = (mx) => {
                        if (Math.abs(mx - sim.state.lensX) < 30) sim.state.dragging = true;
                    };
                    const moveDrag = (mx) => {
                        if (sim.state.dragging) sim.state.lensX = Math.max(50, Math.min(450, mx));
                    };

                    sim.canvas.onmousedown = (e) => {
                        const rect = sim.canvas.getBoundingClientRect();
                        startDrag(e.clientX - rect.left);
                    };
                    sim.canvas.onmousemove = (e) => {
                        const rect = sim.canvas.getBoundingClientRect();
                        moveDrag(e.clientX - rect.left);
                    };
                    sim.canvas.onmouseup = () => sim.state.dragging = false;
                    sim.canvas.onmouseleave = () => sim.state.dragging = false;
                    
                    sim.canvas.ontouchstart = (e) => {
                        const rect = sim.canvas.getBoundingClientRect();
                        startDrag(e.touches[0].clientX - rect.left);
                    };
                    sim.canvas.ontouchmove = (e) => {
                        e.preventDefault();
                        const rect = sim.canvas.getBoundingClientRect();
                        moveDrag(e.touches[0].clientX - rect.left);
                    };
                    sim.canvas.ontouchend = () => sim.state.dragging = false;

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        // Draw Sensor
                        ctx.fillStyle = '#e74c3c';
                        ctx.fillRect(targetX - 5, 150, 10, 50);
                        ctx.fillStyle = '#000'; ctx.fillText("Sensor", targetX - 15, 220);

                        // Draw Lens
                        const lx = sim.state.lensX;
                        ctx.fillStyle = 'rgba(173, 216, 230, 0.5)';
                        ctx.strokeStyle = '#3498db';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.ellipse(lx, 175, 15, 80, 0, 0, Math.PI*2);
                        ctx.fill(); ctx.stroke();

                        // Draw Rays
                        ctx.strokeStyle = '#f1c40f';
                        ctx.lineWidth = 2;
                        const rayY = [115, 145, 175, 205, 235];
                        const focusX = lx + focalLength;

                        rayY.forEach(y => {
                            ctx.beginPath();
                            ctx.moveTo(0, y);
                            ctx.lineTo(lx, y); // To lens
                            // Refract to focus
                            // Calculate extended point
                            const slope = (175 - y) / (focusX - lx);
                            const endX = 600;
                            const endY = y + slope * (endX - lx);
                            ctx.lineTo(endX, endY);
                            ctx.stroke();
                        });

                        // Check Focus
                        if (Math.abs(focusX - targetX) < 15) {
                            document.getElementById('sim-feedback').textContent = "Focused! Lock Opening...";
                            document.getElementById('sim-feedback').className = "mt-3 text-center font-bold text-green-primary";
                            // Visual effect for focus
                            ctx.beginPath(); ctx.arc(targetX, 175, 10, 0, Math.PI*2);
                            ctx.fillStyle = '#fff'; ctx.fill();
                            ctx.shadowBlur = 20; ctx.shadowColor = '#f1c40f'; ctx.stroke(); ctx.shadowBlur = 0;
                        } else {
                            document.getElementById('sim-feedback').textContent = "Adjust lens position to focus light on sensor.";
                            document.getElementById('sim-feedback').className = "mt-3 text-center font-bold text-brand-dark";
                        }

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 7. CHEMISTRY
            chemistry: {
                init: function(sim) {
                    sim.state = { ph: 3, drops: 0 };
                    document.getElementById('sim-controls').innerHTML = `
                        <button onclick="Simulations.state.ph += 0.5; Simulations.state.drops++;" class="px-4 py-2 bg-blue-500 text-white rounded font-bold hover:bg-blue-600">Add Base Drop</button>
                        <button onclick="Simulations.state.ph = 3; Simulations.state.drops=0;" class="ml-4 px-4 py-2 bg-gray-300 text-gray-700 rounded font-bold hover:bg-gray-400">Reset</button>
                    `;

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        // Swamp Water
                        let color;
                        if (sim.state.ph < 5) color = '#e74c3c'; // Red/Acid
                        else if (sim.state.ph < 6.5) color = '#f1c40f'; // Yellow
                        else if (sim.state.ph <= 7.5) color = '#2ecc71'; // Green/Neutral
                        else color = '#3498db'; // Blue/Base
                        
                        ctx.fillStyle = color;
                        ctx.fillRect(0, 100, 600, 250);
                        
                        // Bubbles
                        ctx.fillStyle = 'rgba(255,255,255,0.3)';
                        for(let i=0; i<10; i++) {
                            const x = Math.random()*600; const y = 100 + Math.random()*250;
                            ctx.beginPath(); ctx.arc(x, y, Math.random()*5, 0, Math.PI*2); ctx.fill();
                        }

                        // Meter
                        ctx.fillStyle = '#fff'; ctx.font = "20px Arial";
                        ctx.fillText(`pH Level: ${sim.state.ph.toFixed(1)}`, 20, 40);
                        
                        if (sim.state.ph >= 6.8 && sim.state.ph <= 7.2) {
                            document.getElementById('sim-feedback').textContent = "Water Neutralized! Safe to cross.";
                        } else if (sim.state.ph > 7.5) {
                            document.getElementById('sim-feedback').textContent = "Too Basic!";
                        } else {
                            document.getElementById('sim-feedback').textContent = "Too Acidic!";
                        }

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 8. MAGNETISM
            magnetism: {
                init: function(sim) {
                    sim.state = { active: false, debrisY: 300 };
                    const btn = document.createElement('button');
                    btn.className = "px-4 py-2 bg-red-500 text-white rounded font-bold select-none active:bg-red-700";
                    btn.textContent = "Activate Magnet";
                    btn.onmousedown = () => sim.state.active = true;
                    btn.onmouseup = () => sim.state.active = false;
                    btn.onmouseleave = () => sim.state.active = false;
                    // Touch support
                    btn.ontouchstart = (e) => { e.preventDefault(); sim.state.active = true; };
                    btn.ontouchend = (e) => { e.preventDefault(); sim.state.active = false; };
                    
                    document.getElementById('sim-controls').appendChild(btn);

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        // Crane
                        ctx.fillStyle = '#f1c40f'; ctx.fillRect(250, 0, 20, 100);
                        // Magnet
                        ctx.fillStyle = sim.state.active ? '#e74c3c' : '#95a5a6';
                        ctx.fillRect(200, 100, 120, 40);
                        
                        // Field Lines
                        if(sim.state.active) {
                            ctx.strokeStyle = 'rgba(231, 76, 60, 0.5)'; ctx.lineWidth = 2;
                            for(let i=0; i<5; i++) {
                                ctx.beginPath(); ctx.arc(260, 140, 20 + i*10, 0, Math.PI, false); ctx.stroke();
                            }
                            // Physics
                            if(sim.state.debrisY > 140) sim.state.debrisY -= 5;
                        } else {
                            if(sim.state.debrisY < 300) sim.state.debrisY += 10;
                        }

                        // Debris
                        ctx.fillStyle = '#7f8c8d';
                        ctx.fillRect(220, sim.state.debrisY, 80, 50);
                        ctx.fillStyle = '#fff'; ctx.fillText("Scrap", 260, sim.state.debrisY + 30);

                        if(sim.state.debrisY <= 150) document.getElementById('sim-feedback').textContent = "Path Cleared!";
                        else document.getElementById('sim-feedback').textContent = "Path Blocked.";

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 9. CIRCUIT
            circuit: {
                init: function(sim) {
                    // 0: Horiz, 1: Vert
                    sim.state = { w1: 1, w2: 0, w3: 1 }; 
                    sim.canvas.onclick = (e) => {
                        const rect = sim.canvas.getBoundingClientRect();
                        const mx = e.clientX - rect.left;
                        if (mx > 100 && mx < 200) sim.state.w1 = 1 - sim.state.w1;
                        if (mx > 250 && mx < 350) sim.state.w2 = 1 - sim.state.w2;
                        if (mx > 400 && mx < 500) sim.state.w3 = 1 - sim.state.w3;
                    };
                    document.getElementById('sim-feedback').textContent = "Click wires to rotate.";

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        const connected = (sim.state.w1 === 0 && sim.state.w2 === 0 && sim.state.w3 === 0);
                        const color = connected ? '#f1c40f' : '#7f8c8d';

                        // Battery
                        ctx.fillStyle = '#34495e'; ctx.fillRect(20, 150, 40, 50);
                        
                        // Wires
                        ctx.lineWidth = 8; ctx.strokeStyle = color;
                        
                        // Segment 1
                        ctx.beginPath(); 
                        if(sim.state.w1 === 0) { ctx.moveTo(60, 175); ctx.lineTo(200, 175); } // Correct
                        else { ctx.moveTo(130, 105); ctx.lineTo(130, 245); }
                        ctx.stroke();

                        // Segment 2
                        ctx.beginPath(); 
                        if(sim.state.w2 === 0) { ctx.moveTo(200, 175); ctx.lineTo(350, 175); } // Correct
                        else { ctx.moveTo(275, 105); ctx.lineTo(275, 245); }
                        ctx.stroke();

                        // Segment 3
                        ctx.beginPath(); 
                        if(sim.state.w3 === 0) { ctx.moveTo(350, 175); ctx.lineTo(500, 175); } // Correct
                        else { ctx.moveTo(425, 105); ctx.lineTo(425, 245); }
                        ctx.stroke();

                        // Lock/Light
                        ctx.fillStyle = connected ? '#2ecc71' : '#c0392b';
                        ctx.beginPath(); ctx.arc(530, 175, 20, 0, Math.PI*2); ctx.fill();
                        
                        if(connected) document.getElementById('sim-feedback').textContent = "Circuit Complete! Gate Open.";

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 10. GENERATOR
            generator: {
                init: function(sim) {
                    sim.state = { angle: 0, speed: 0, energy: 0 };
                    let lastX = 0;
                    
                    sim.canvas.onmousemove = (e) => {
                        const delta = Math.abs(e.clientX - lastX);
                        sim.state.speed += delta * 0.01;
                        lastX = e.clientX;
                    };
                    // Touch support
                    sim.canvas.ontouchmove = (e) => {
                        const delta = Math.abs(e.touches[0].clientX - lastX);
                        sim.state.speed += delta * 0.01;
                        lastX = e.touches[0].clientX;
                    };

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        sim.state.speed *= 0.95; // Friction
                        sim.state.angle += sim.state.speed;
                        sim.state.energy = Math.min(100, sim.state.energy + sim.state.speed * 0.1);

                        // Wheel
                        ctx.save();
                        ctx.translate(300, 175);
                        ctx.rotate(sim.state.angle);
                        ctx.fillStyle = '#95a5a6';
                        ctx.beginPath(); ctx.arc(0, 0, 80, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = '#7f8c8d';
                        ctx.fillRect(-10, -80, 20, 160); ctx.fillRect(-80, -10, 160, 20);
                        ctx.restore();

                        // Energy Bar
                        ctx.fillStyle = '#ecf0f1'; ctx.fillRect(150, 300, 300, 20);
                        ctx.fillStyle = '#f1c40f'; ctx.fillRect(150, 300, sim.state.energy * 3, 20);
                        ctx.strokeStyle = '#2c3e50'; ctx.strokeRect(150, 300, 300, 20);

                        if(sim.state.energy >= 100) {
                            document.getElementById('sim-feedback').textContent = "Generator Online!";
                            ctx.shadowBlur = 20; ctx.shadowColor = '#f1c40f';
                        } else {
                            document.getElementById('sim-feedback').textContent = "Spin faster!";
                            ctx.shadowBlur = 0;
                        }

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 11. GRID
            grid: {
                init: function(sim) {
                    sim.state = {
                        nodes: [
                            {x: 50, y: 175, type: 'source', connected: true},
                            {x: 200, y: 100, type: 'node', connected: false},
                            {x: 200, y: 250, type: 'node', connected: false},
                            {x: 350, y: 175, type: 'node', connected: false},
                            {x: 500, y: 100, type: 'house', connected: false},
                            {x: 500, y: 250, type: 'house', connected: false}
                        ],
                        adj: [ // Adjacency list for the graph
                            [1, 2],    // 0
                            [0, 3],    // 1
                            [0, 3],    // 2
                            [1, 2, 4, 5], // 3
                            [3],       // 4
                            [3]        // 5
                        ]
                    };

                    // Helper to check for a powered path from a node to the source (index 0)
                    sim.isPowered = (startNodeIndex) => {
                        const nodes = sim.state.nodes;
                        const adj = sim.state.adj;

                        // The node must be 'on' to be part of a path
                        if (!nodes[startNodeIndex].connected) return false;
                        
                        let queue = [startNodeIndex];
                        let visited = new Set([startNodeIndex]);

                        while(queue.length > 0) {
                            const u = queue.shift();
                            if (u === 0) return true; // Reached the source, which is always powered

                            for (const v of adj[u]) {
                                if (!visited.has(v) && nodes[v].connected) {
                                    visited.add(v);
                                    queue.push(v);
                                }
                            }
                        }
                        return false;
                    };

                    sim.canvas.onclick = (e) => {
                        const rect = sim.canvas.getBoundingClientRect();
                        const mx = e.clientX - rect.left;
                        const my = e.clientY - rect.top;
                        
                        sim.state.nodes.forEach(n => {
                            if(Math.sqrt((mx-n.x)**2 + (my-n.y)**2) < 20) {
                                // Simple logic: if clicked, toggle its connection state
                                if(n.type !== 'source') n.connected = !n.connected;
                            }
                        });
                    };

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.clearRect(0,0,600,350);
                        
                        // Draw Lines (Simplified hardcoded connections)
                        const drawLine = (i1, i2) => {
                            const n1 = sim.state.nodes[i1]; const n2 = sim.state.nodes[i2];
                            // A line is powered if both its endpoints have a path to the source.
                            const linePowered = sim.isPowered(i1) && sim.isPowered(i2);
                            ctx.strokeStyle = linePowered ? '#f1c40f' : '#7f8c8d';
                            ctx.lineWidth = 4;
                            ctx.beginPath(); ctx.moveTo(n1.x, n1.y); ctx.lineTo(n2.x, n2.y); ctx.stroke();
                        };
                        
                        drawLine(0, 1); drawLine(0, 2);
                        drawLine(1, 3); drawLine(2, 3);
                        drawLine(3, 4); drawLine(3, 5);

                        // Draw Nodes
                        let allNodesClicked = true;
                        sim.state.nodes.forEach((n, i) => {
                            // The source node is always connected. For all other nodes,
                            // if they are not connected, the puzzle is not solved.
                            if (n.type !== 'source' && !n.connected) {
                                allNodesClicked = false;
                            }

                            const isNodePowered = sim.isPowered(i);

                            // Determine node color based on its type and state
                            if (n.type === 'source') {
                                ctx.fillStyle = '#2ecc71'; // Source is always green and powered
                            } else if (n.type === 'house') {
                                // A house is only visually "powered" (yellow) if it has a path to the source.
                                ctx.fillStyle = isNodePowered ? '#f1c40f' : '#e74c3c';
                            } else { // Regular intermediate node
                                // A regular node is yellow only if it has a path to the source.
                                ctx.fillStyle = isNodePowered ? '#f1c40f' : '#34495e';
                            }

                            ctx.beginPath(); ctx.arc(n.x, n.y, 15, 0, Math.PI*2); ctx.fill();
                            ctx.strokeStyle = '#fff'; ctx.stroke();
                        });

                        if (allNodesClicked) {
                            document.getElementById('sim-feedback').textContent = "Grid Fully Operational!";
                        } else {
                            document.getElementById('sim-feedback').textContent = "Connect all nodes to power the houses.";
                        }

                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 12. FIREWORKS
            fireworks: {
                init: function(sim) {
                    sim.state = { particles: [] };
                    
                    sim.canvas.onclick = (e) => {
                        const rect = sim.canvas.getBoundingClientRect();
                        const mx = e.clientX - rect.left;
                        const my = e.clientY - rect.top;
                        for(let i=0; i<30; i++) {
                            sim.state.particles.push({
                                x: mx, y: my,
                                vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5,
                                life: 1, color: `hsl(${Math.random()*360}, 100%, 50%)`
                            });
                        }
                    };

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        ctx.fillStyle = 'rgba(44, 62, 80, 0.2)'; // Trails
                        ctx.fillRect(0,0,600,350);
                        
                        for(let i=sim.state.particles.length-1; i>=0; i--) {
                            const p = sim.state.particles[i];
                            p.x += p.vx; p.y += p.vy; p.vy += 0.05; // Gravity
                            p.life -= 0.02;
                            
                            ctx.fillStyle = p.color;
                            ctx.globalAlpha = p.life;
                            ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
                            ctx.globalAlpha = 1;
                            
                            if(p.life <= 0) sim.state.particles.splice(i, 1);
                        }

                        document.getElementById('sim-feedback').textContent = "Technopolis is Saved!";
                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            },

            // 13. SANDBOX
            sandbox: {
                init: function(sim) {
                    sim.state = { bodies: [] };
                    
                    sim.canvas.onclick = (e) => {
                        const rect = sim.canvas.getBoundingClientRect();
                        const mx = e.clientX - rect.left;
                        const my = e.clientY - rect.top;
                        
                        sim.state.bodies.push({
                            x: mx, y: my,
                            vx: (Math.random() - 0.5) * 2, vy: 0,
                            type: Math.random() > 0.5 ? 'rect' : 'circle',
                            size: Math.random() * 30 + 20,
                            color: `hsl(${Math.random()*360}, 70%, 60%)`,
                            mass: 1
                        });
                        const last = sim.state.bodies[sim.state.bodies.length-1];
                        last.mass = last.type === 'rect' ? (last.size * last.size) : (Math.PI * (last.size/2)**2);
                    };

                    sim.loop = () => {
                        const ctx = sim.ctx;
                        const w = sim.canvas.width;
                        const h = sim.canvas.height;
                        
                        ctx.clearRect(0, 0, w, h);
                        
                        const gravity = 0.5;
                        const friction = 0.98;
                        const restitution = 0.05; // Lowered for less bounce and better stacking

                        // 1. Apply Forces & Move
                        sim.state.bodies.forEach(b => {
                            b.vy += gravity;
                            b.vx *= friction;
                            b.x += b.vx;
                            b.y += b.vy;
                        });

                        // 2. Resolve Collisions (Iterative)
                        const iterations = 5;
                        for(let k=0; k<iterations; k++) {
                            // Boundary Collisions
                            sim.state.bodies.forEach(b => {
                                const half = b.size / 2;
                                if (b.y + half > h) { 
                                    b.y = h - half; 
                                    b.vy *= -restitution; 
                                    b.vx *= 0.9; 
                                }
                                if (b.x - half < 0) { b.x = half; b.vx *= -restitution; }
                                if (b.x + half > w) { b.x = w - half; b.vx *= -restitution; }
                            });

                            // Body vs Body
                            for (let i = 0; i < sim.state.bodies.length; i++) {
                                for (let j = i + 1; j < sim.state.bodies.length; j++) {
                                    const b1 = sim.state.bodies[i];
                                    const b2 = sim.state.bodies[j];
                                    
                                    let collision = false;
                                    let nx = 0, ny = 0, pen = 0;

                                    if (b1.type === 'circle' && b2.type === 'circle') {
                                        const dx = b2.x - b1.x;
                                        const dy = b2.y - b1.y;
                                        const dist = Math.sqrt(dx*dx + dy*dy);
                                        const minDist = (b1.size + b2.size) / 2;
                                        if (dist < minDist) {
                                            collision = true;
                                            pen = minDist - dist;
                                            if (dist === 0) { nx = 0; ny = 1; } 
                                            else { nx = dx / dist; ny = dy / dist; }
                                        }
                                    } else if (b1.type === 'rect' && b2.type === 'rect') {
                                        const dx = b2.x - b1.x;
                                        const dy = b2.y - b1.y;
                                        const wCombined = (b1.size + b2.size) / 2;
                                        const hCombined = (b1.size + b2.size) / 2;
                                        if (Math.abs(dx) < wCombined && Math.abs(dy) < hCombined) {
                                            collision = true;
                                            const ox = wCombined - Math.abs(dx);
                                            const oy = hCombined - Math.abs(dy);
                                            if (ox < oy) { pen = ox; nx = dx > 0 ? 1 : -1; ny = 0; } 
                                            else { pen = oy; nx = 0; ny = dy > 0 ? 1 : -1; }
                                        }
                                    } else {
                                        const circ = b1.type === 'circle' ? b1 : b2;
                                        const rect = b1.type === 'circle' ? b2 : b1;
                                        const closestX = Math.max(rect.x - rect.size/2, Math.min(circ.x, rect.x + rect.size/2));
                                        const closestY = Math.max(rect.y - rect.size/2, Math.min(circ.y, rect.y + rect.size/2));
                                        const dx = circ.x - closestX;
                                        const dy = circ.y - closestY;
                                        const distSq = dx*dx + dy*dy;
                                        if (distSq < (circ.size/2)**2) {
                                            collision = true;
                                            const dist = Math.sqrt(distSq);
                                            pen = (circ.size/2) - dist;
                                            if (dist === 0) {
                                                const dx2 = circ.x - rect.x; const dy2 = circ.y - rect.y;
                                                if (Math.abs(dx2) > Math.abs(dy2)) { nx = dx2 > 0 ? 1 : -1; ny = 0; } else { nx = 0; ny = dy2 > 0 ? 1 : -1; }
                                            } else { nx = dx / dist; ny = dy / dist; }
                                            if (b1.type === 'rect') { nx = -nx; ny = -ny; }
                                        }
                                    }

                                    if (collision) {
                                        // Positional Correction (with slop to prevent jitter)
                                        const slop = 0.5; // Allow this much penetration
                                        const percent = 0.4; // Correct by this percentage to avoid over-correction
                                        const correction = Math.max(0, pen - slop) / (1/b1.mass + 1/b2.mass) * percent;
                                        b1.x -= (1/b1.mass) * correction * nx;
                                        b1.y -= (1/b1.mass) * correction * ny;
                                        b2.x += (1/b2.mass) * correction * nx;
                                        b2.y += (1/b2.mass) * correction * ny;

                                        const rvx = b2.vx - b1.vx; const rvy = b2.vy - b1.vy;
                                        const velAlongNormal = rvx * nx + rvy * ny;

                                        // Only apply impulse if they are moving towards each other
                                        if (velAlongNormal < 0) {
                                            let j = -(1 + restitution) * velAlongNormal;
                                            j /= (1/b1.mass + 1/b2.mass);
                                            const impulseX = j * nx; const impulseY = j * ny;
                                            b1.vx -= impulseX / b1.mass; b1.vy -= impulseY / b1.mass;
                                            b2.vx += impulseX / b2.mass; b2.vy += impulseY / b2.mass;
                                        }
                                    }
                                }
                            }
                        }

                        sim.state.bodies.forEach(body => {
                            ctx.fillStyle = body.color;
                            ctx.strokeStyle = '#2c3e50';
                            ctx.lineWidth = 2;
                            if (body.type === 'rect') { 
                                ctx.fillRect(body.x - body.size/2, body.y - body.size/2, body.size, body.size); 
                                ctx.strokeRect(body.x - body.size/2, body.y - body.size/2, body.size, body.size);
                            } else { 
                                ctx.beginPath(); 
                                ctx.arc(body.x, body.y, body.size/2, 0, Math.PI*2); 
                                ctx.fill(); 
                                ctx.stroke();
                            }
                        });
                        sim.animId = requestAnimationFrame(sim.loop);
                    };
                    sim.loop();
                }
            }
        };

        // Initialize
        window.onload = function() {
            Book.init();
        };
    </script>
</body>
</html>